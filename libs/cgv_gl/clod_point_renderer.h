#pragma once
#include <cgv/render/context.h>
#include <cgv/render/shader_program.h>
#include <cgv/render/vertex_buffer.h>
#include <cgv/render/attribute_array_binding.h>
#include <cgv/reflect/reflect_extern.h>
#include <cgv_gl/gl/gl_context.h>
#include <cgv_reflect_types/render/context.h>
#include <atomic>
#include <mutex>
#include <array>
#include "renderer.h"

#include "gl/lib_begin.h"

// source code of the continous level of detail point cloud renderer adapted for the cgv framework

// original paper: "Real-Time Continuous Level of Detail Rendering of Point Clouds" from Schutz, Markus and Krosl, Katharina and Wimmer, Michael
// the reference implementation can be found at https://github.com/m-schuetz/ieeevr_2019_clod

namespace cgv {
	namespace render {

		class clod_point_renderer;

		
		//stores and manages point buffers modified by the reduce step
		class CGV_API clod_point_buffer_manager
		{
			/// buffer contains all points that should be drawn on screen
			GLuint points;
			/// the referred buffer contains ids of points after reduction
			GLuint indices;
			/// draw_parameter_buffer contains the parameters required for indirect drawing
			GLuint draw_parameters;
			GLuint vertex_array;
			GLuint max_num_points = 0;
		  protected:
			GLuint get_vertex_array();
		  public:
			void init(context& ctx);

			void clear(context& ctx);

			void resize(GLuint size);

			/// get the opengl id used to access the index buffer
			GLuint get_index_buffer();

			/// get the opengl id used to access the internal draw parameters
			GLuint get_draw_parameters();

			/// get the opengl id used to access the internal draw buffer
			GLuint get_reduced_points();
			/// maps draw_parameters to memory and reads size
			GLuint num_reduced_points();
			/// max number of points stored in the managed buffers without resizing
			GLuint size();

			friend class clod_point_renderer;
		};
		

		extern CGV_API clod_point_renderer& ref_clod_point_renderer(context& ctx, int ref_count_change = 0);

		/** render style for sphere rendere */
		struct CGV_API clod_point_render_style : public render_style
		{
			/*@name clod rendering attributes*/
			//@{
			// clod factor, affects the distance dependent target spacing
			float CLOD;
			/** := root spacing, match this to your inputs point spacing in the octrees root level, 
				too low values may cause most of the pointcloud to go invisible */
			float spacing;
			// scales the target spacing
			float scale;
			// minimal size of the visible points
			float min_millimeters;
			float pointSize;
			// draw circles instead of squares
			bool draw_circles = false;
			//@}
		  private:
			char reserved_space[36]; //this is here to fix some mess in serialization

		  public:
			/// construct with default values
			clod_point_render_style();
		};


		//*  */
		class CGV_API clod_point_renderer {
		public:
			// internal point format, made to fit inside 16 bytes
			struct Point {
				vec3 p_position;
				rgb8 p_color;
				uint8_t p_level = 0;

				Point() = default;

				//conversion from other point formats
				template <typename P>
				Point(const P& pnt) {
					p_position = pnt.position();
					p_color = pnt.color();
					p_level = pnt.level();
				}

				inline vec3& position() {
					return p_position;
				}
				/// returns the level of detail
				inline uint8_t& level() {
					return p_level;
				}
				inline rgb8& color() {
					return p_color;
				}
				inline const vec3& position() const {
					return p_position;
				}
				/// return the level of detail
				inline const uint8_t& level() const {
					return p_level;
				}
				inline const rgb8& color() const {
					return p_color;
				}
			};

		private:
			shader_program reduce_prog;		// filters points from the input buffer and writes them to the render_buffer (compute shader)
			shader_program* draw_prog_ptr;
			shader_program draw_prog;	// draws render_buffer (vertex, geometry, fragment shader)
			
			clod_point_buffer_manager buffer_manager;
			clod_point_buffer_manager* active_buffer_manager_ptr;

			GLuint active_vertex_array = 0;
			//internal buffers, 
			// input buffer stores all points given by set points
			// render buffer contains all points that should be drawn on screen
			// draw_parameter_buffer contains the parameters required for indirect drawing
			// render_buffer and draw_parameter_buffer are generated by the reduce methods and
			GLuint input_buffer = 0;
			//active buffers (may be externals)
			GLuint active_render_buffer = 0, active_draw_parameter_buffer = 0, active_index_buffer = 0;
			/// buffer layout positions for the reduce shader program
			const int input_pos = 0, render_pos = 1, index_pos = 2,drawp_pos = 3, input_id_pos = 4;

			GLsizeiptr input_buffer_size = 0;
			GLuint input_buffer_num_points = 0;
			
			bool buffers_outofdate = true;

			float frustum_extend = 1.f;

			vec4 pivot_point_in_view_space;



			/// default render style
			mutable render_style* default_render_style = nullptr;
			/// current render style, can be set by user
			const render_style* rs = nullptr;

			//cached uniform locations
			struct uniform_locations {
				int batch_offset,
					batch_size,
					CLOD,
					scale,
					spacing,
					screenSize,
					pivot,
					frustum_extent,
					protection_zone_points,
					target_buffer_size;
				//uniform blocks
				int CLODParameterBlock;
			} uniforms;

		protected:			
			const render_style* get_style_ptr() const;

			template <typename T>
			const T& get_style() const { return *static_cast<const T*>(get_style_ptr()); }

		public:
			clod_point_renderer();

			render_style* create_render_style() const;

			bool init(context& ctx);

			/// sets most uniforms
			bool enable(context& ctx);

			bool enable(context& ctx, const mat4& reduction_model_view_matrix);

			bool enable_buffer_manager(clod_point_buffer_manager& manager);

			void disable_buffer_manager();

			bool disable(context& ctx);

			void clear(cgv::render::context& ctx);

			/// reduces and renders the input by calling reduce_points and draw_points
			void draw(context& ctx, size_t start=0, size_t count=0);
			
			bool render(context& ctx, size_t start, size_t count);

			/// this method can be used if the data format of pnts matches with the internal format given by the Point struct
			void set_points(cgv::render::context& ctx, const Point* pnts, const size_t num_points);

			/// to use the clod point renderer lods are required, to generate them use the classes inside libs/pointcloud/octree.h
			/// @param positions : pointer to first points position
			/// @param color : pointer to first points color
			/// @param lods : pointer to firsts points level of detail
			/// @param num_points : number of points to draw
			/// @param stride : stride in bytes, zero if positions, color and lods are not stored interleaved
			void set_points(cgv::render::context& ctx, const vec3* positions, const rgb8* colors, const uint8_t* lods, const size_t num_points, const unsigned stride = 0);
			/*
			// sets an already existing buffer as input
			void set_points(cgv::render::context& ctx, GLint input_buffer, const size_t num_points);
			

			*/
			void set_frustum_extend(const float& fe);

			void set_max_drawn_points(cgv::render::context& ctx, const unsigned max_points);
			
			//sets the pivot point in view space coordinates
			void set_pivot_point(const vec4& pivot);

			void set_render_style(const render_style& rs);
			
			void manage_singelton(context& ctx, const std::string& renderer_name, int& ref_count, int ref_count_change);

			/// set a custom shader program that is used for one enable disable cycle
			void set_prog(shader_program& one_shot_prog);
			

			/* methods for step wise operation*/

			/// initializes reduce,
			/// @param reset_parameters : resets draw parameter buffer
			void reduce_buffer_init(context& ctx, bool reset_parameters = true);
			/// reduces a provided opengl buffer
			void reduce_buffer(context& ctx, const GLuint buffer,const GLuint point_id_buffer, size_t start, size_t count);

			void reduce_buffer_finish(context& ctx);

			/// run point reduction step on the input data, you need to call enable first
			void reduce_points(context& ctx, size_t start, size_t count);
			/// do a point reduction over preselected segments of the input buffer
			/// @param chunk_starts index of the first point in a chunk
			/// @param chunk_point_counts number of points in each chunk
			/// @param reduction_sources ids of chunks considered for reduction
			void reduce_chunks(context& ctx, const uint32_t* chunk_starts, const uint32_t* chunk_point_counts, const uint32_t* reduction_sources, uint32_t num_reduction_sources);
			
			/// render reduced points, you need to call reduce_points first to fill the render_buffer
			void draw_points(context& ctx);
			
		  public:
			/// gives the number of points written to the reduction buffer
			unsigned int num_reduced_points();

		private:
			void add_shader(context& ctx, shader_program& prog, const std::string& sf, const cgv::render::ShaderType st);
			void clear_buffers(context& ctx);
			static void reset_draw_parameters(context& ctx, GLuint draw_parameter_buffer);
		};


		struct CGV_API clod_point_render_style_reflect : public clod_point_render_style
		{
			bool self_reflect(cgv::reflect::reflection_handler& rh);
		};
		extern CGV_API cgv::reflect::extern_reflection_traits<clod_point_render_style, clod_point_render_style_reflect> get_reflection_traits(const clod_point_render_style&);

	}
}
#include <cgv/config/lib_end.h>