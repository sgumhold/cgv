<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cgv: cgv::media::image::abst_image_reader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cgv
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classcgv_1_1media_1_1image_1_1abst__image__reader.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="classcgv_1_1media_1_1image_1_1abst__image__reader-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cgv::media::image::abst_image_reader Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>abstract interface for image readers  
 <a href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="image__reader_8h_source.html">image_reader.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cgv::media::image::abst_image_reader:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcgv_1_1media_1_1image_1_1abst__image__reader.png" usemap="#cgv::media::image::abst_5Fimage_5Freader_map" alt=""/>
  <map id="cgv::media::image::abst_5Fimage_5Freader_map" name="cgv::media::image::abst_5Fimage_5Freader_map">
<area href="classcgv_1_1base_1_1base.html" alt="cgv::base::base" shape="rect" coords="117,56,342,80"/>
<area href="classcgv_1_1data_1_1ref__counted.html" alt="cgv::data::ref_counted" shape="rect" coords="0,0,225,24"/>
<area href="structcgv_1_1reflect_1_1self__reflection__tag.html" title="Derive from this class to announce implementation of the method self_reflect." alt="cgv::reflect::self_reflection_tag" shape="rect" coords="235,0,460,24"/>
<area href="classcgv_1_1media_1_1image_1_1bmp__reader.html" title="implements the image reader interface for bmp files" alt="cgv::media::image::bmp_reader" shape="rect" coords="117,168,342,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af41fed5f642b279f226f3ee8acba3703"><td class="memItemLeft" align="right" valign="top"><a id="af41fed5f642b279f226f3ee8acba3703"></a>
virtual <a class="el" href="classcgv_1_1media_1_1image_1_1abst__image__reader.html">abst_image_reader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#af41fed5f642b279f226f3ee8acba3703">clone</a> () const =0</td></tr>
<tr class="memdesc:af41fed5f642b279f226f3ee8acba3703"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct a copy of the reader <br /></td></tr>
<tr class="separator:af41fed5f642b279f226f3ee8acba3703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79680ae11d743619d3df14e53474358e"><td class="memItemLeft" align="right" valign="top"><a id="a79680ae11d743619d3df14e53474358e"></a>
virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#a79680ae11d743619d3df14e53474358e">get_last_error</a> () const =0</td></tr>
<tr class="memdesc:a79680ae11d743619d3df14e53474358e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a reference to the last error message <br /></td></tr>
<tr class="separator:a79680ae11d743619d3df14e53474358e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e473035dcd857291a52a0d8529701dc"><td class="memItemLeft" align="right" valign="top"><a id="a2e473035dcd857291a52a0d8529701dc"></a>
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#a2e473035dcd857291a52a0d8529701dc">get_supported_extensions</a> () const =0</td></tr>
<tr class="memdesc:a2e473035dcd857291a52a0d8529701dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a string containing a colon separated list of extensions that can be read with this reader <br /></td></tr>
<tr class="separator:a2e473035dcd857291a52a0d8529701dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21741f88130baa3224809472f69df8b5"><td class="memItemLeft" align="right" valign="top"><a id="a21741f88130baa3224809472f69df8b5"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#a21741f88130baa3224809472f69df8b5">open</a> (const std::string &amp;file_name, <a class="el" href="classcgv_1_1data_1_1data__format.html">data_format</a> &amp;df, std::vector&lt; <a class="el" href="classcgv_1_1data_1_1data__format.html">data_format</a> &gt; *palette_formats)=0</td></tr>
<tr class="memdesc:a21741f88130baa3224809472f69df8b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">open the file and read the image header in order to determine the data format <br /></td></tr>
<tr class="separator:a21741f88130baa3224809472f69df8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ada7393c90cdec16d2ca107872eb7aa"><td class="memItemLeft" align="right" valign="top"><a id="a5ada7393c90cdec16d2ca107872eb7aa"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#a5ada7393c90cdec16d2ca107872eb7aa">supports_per_line_read</a> () const =0</td></tr>
<tr class="memdesc:a5ada7393c90cdec16d2ca107872eb7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the reader supports per line reading (only valid after successful opening an image file <br /></td></tr>
<tr class="separator:a5ada7393c90cdec16d2ca107872eb7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44291ffc79277a0d6f3e70c92482ba5f"><td class="memItemLeft" align="right" valign="top"><a id="a44291ffc79277a0d6f3e70c92482ba5f"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#a44291ffc79277a0d6f3e70c92482ba5f">supports_multiple_images</a> () const</td></tr>
<tr class="memdesc:a44291ffc79277a0d6f3e70c92482ba5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the file can contain several images <br /></td></tr>
<tr class="separator:a44291ffc79277a0d6f3e70c92482ba5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad823ad70517819be61b46476248c014e"><td class="memItemLeft" align="right" valign="top"><a id="ad823ad70517819be61b46476248c014e"></a>
virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#ad823ad70517819be61b46476248c014e">get_nr_images</a> () const</td></tr>
<tr class="memdesc:ad823ad70517819be61b46476248c014e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of images in the file, what can cause the whole file to be scanned <br /></td></tr>
<tr class="separator:ad823ad70517819be61b46476248c014e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1a2ab5612d425e69373e8ad66e69c9"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#a1c1a2ab5612d425e69373e8ad66e69c9">get_image_duration</a> () const</td></tr>
<tr class="memdesc:a1c1a2ab5612d425e69373e8ad66e69c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the duration of the current image in seconds, if returned value is 0, no duration is available  <a href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#a1c1a2ab5612d425e69373e8ad66e69c9">More...</a><br /></td></tr>
<tr class="separator:a1c1a2ab5612d425e69373e8ad66e69c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2705c71423ae57642e269f2eb8940c"><td class="memItemLeft" align="right" valign="top"><a id="a6c2705c71423ae57642e269f2eb8940c"></a>
virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#a6c2705c71423ae57642e269f2eb8940c">get_current_image</a> () const</td></tr>
<tr class="memdesc:a6c2705c71423ae57642e269f2eb8940c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the index of the current image <br /></td></tr>
<tr class="separator:a6c2705c71423ae57642e269f2eb8940c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadacfa0013afdd1a33519ae94c9b675d"><td class="memItemLeft" align="right" valign="top"><a id="aadacfa0013afdd1a33519ae94c9b675d"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#aadacfa0013afdd1a33519ae94c9b675d">seek_image</a> (unsigned idx)</td></tr>
<tr class="memdesc:aadacfa0013afdd1a33519ae94c9b675d"><td class="mdescLeft">&#160;</td><td class="mdescRight">jump to a specific image and return whether this was successful <br /></td></tr>
<tr class="separator:aadacfa0013afdd1a33519ae94c9b675d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87eb9fee9edaf1814c66bd625d16ec9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#af87eb9fee9edaf1814c66bd625d16ec9">read_palette</a> (unsigned int i, const <a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &amp;dv)</td></tr>
<tr class="memdesc:af87eb9fee9edaf1814c66bd625d16ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">read the i-th palette in case of a paletted file format, the standard implementation returns false  <a href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#af87eb9fee9edaf1814c66bd625d16ec9">More...</a><br /></td></tr>
<tr class="separator:af87eb9fee9edaf1814c66bd625d16ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd444e1f0903a178c082d69fa8145099"><td class="memItemLeft" align="right" valign="top"><a id="afd444e1f0903a178c082d69fa8145099"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#afd444e1f0903a178c082d69fa8145099">read_line</a> (const <a class="el" href="classcgv_1_1data_1_1data__format.html">data_format</a> &amp;df, const <a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &amp;dv)=0</td></tr>
<tr class="memdesc:afd444e1f0903a178c082d69fa8145099"><td class="mdescLeft">&#160;</td><td class="mdescRight">read the next line into the given data pointer, set data format if not yet specified and allocate the data ptr if not yet done <br /></td></tr>
<tr class="separator:afd444e1f0903a178c082d69fa8145099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3811feeb4f9c0c1b50e6985764af9bf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#af3811feeb4f9c0c1b50e6985764af9bf">read_image</a> (const <a class="el" href="classcgv_1_1data_1_1data__format.html">data_format</a> &amp;df, const <a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &amp;dv)=0</td></tr>
<tr class="memdesc:af3811feeb4f9c0c1b50e6985764af9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">read an image into the given data pointer.  <a href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#af3811feeb4f9c0c1b50e6985764af9bf">More...</a><br /></td></tr>
<tr class="separator:af3811feeb4f9c0c1b50e6985764af9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecaaabb840c707876734a1fad58ce1cb"><td class="memItemLeft" align="right" valign="top"><a id="aecaaabb840c707876734a1fad58ce1cb"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#aecaaabb840c707876734a1fad58ce1cb">close</a> ()=0</td></tr>
<tr class="memdesc:aecaaabb840c707876734a1fad58ce1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">close the image file <br /></td></tr>
<tr class="separator:aecaaabb840c707876734a1fad58ce1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e64a898476591f7246e522652abfa4c"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a6e64a898476591f7246e522652abfa4c">get_type_name</a> () const</td></tr>
<tr class="memdesc:a6e64a898476591f7246e522652abfa4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload to return the type name of this object. By default the type interface is queried over get_type.  <a href="classcgv_1_1base_1_1base.html#a6e64a898476591f7246e522652abfa4c">More...</a><br /></td></tr>
<tr class="separator:a6e64a898476591f7246e522652abfa4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a9ca57ee7e6364153cda52223b8501"><td class="memItemLeft" align="right" valign="top"><a id="a79a9ca57ee7e6364153cda52223b8501"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a79a9ca57ee7e6364153cda52223b8501">get_default_options</a> () const</td></tr>
<tr class="memdesc:a79a9ca57ee7e6364153cda52223b8501"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload to provide default options for registration <br /></td></tr>
<tr class="separator:a79a9ca57ee7e6364153cda52223b8501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f074aea5bf4b0bfeb00845750d27623"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a2f074aea5bf4b0bfeb00845750d27623">on_register</a> ()</td></tr>
<tr class="memdesc:a2f074aea5bf4b0bfeb00845750d27623"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload to handle register events that is sent after the instance has been registered  <a href="classcgv_1_1base_1_1base.html#a2f074aea5bf4b0bfeb00845750d27623">More...</a><br /></td></tr>
<tr class="separator:a2f074aea5bf4b0bfeb00845750d27623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3db0f57373229e66422eeeb6750ebc"><td class="memItemLeft" align="right" valign="top"><a id="a0b3db0f57373229e66422eeeb6750ebc"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a0b3db0f57373229e66422eeeb6750ebc">unregister</a> ()</td></tr>
<tr class="memdesc:a0b3db0f57373229e66422eeeb6750ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload to handle unregistration of instances <br /></td></tr>
<tr class="separator:a0b3db0f57373229e66422eeeb6750ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313232084b52192201cecaf4ae257ee8"><td class="memItemLeft" align="right" valign="top"><a id="a313232084b52192201cecaf4ae257ee8"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a313232084b52192201cecaf4ae257ee8">on_exit_request</a> ()</td></tr>
<tr class="memdesc:a313232084b52192201cecaf4ae257ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload to handle the appication exit request, return true if exiting is allowed and false otherwise <br /></td></tr>
<tr class="separator:a313232084b52192201cecaf4ae257ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bafefa81ebfa3206014eb198e49459"><td class="memItemLeft" align="right" valign="top"><a id="a95bafefa81ebfa3206014eb198e49459"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a95bafefa81ebfa3206014eb198e49459">stream_stats</a> (std::ostream &amp;)</td></tr>
<tr class="memdesc:a95bafefa81ebfa3206014eb198e49459"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload to show the content of this object <br /></td></tr>
<tr class="separator:a95bafefa81ebfa3206014eb198e49459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2b95a4802d2a4fc33b556726e0656f"><td class="memItemLeft" align="right" valign="top"><a id="a6d2b95a4802d2a4fc33b556726e0656f"></a>
virtual <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; named, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a6d2b95a4802d2a4fc33b556726e0656f">get_named</a> ()</td></tr>
<tr class="memdesc:a6d2b95a4802d2a4fc33b556726e0656f"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast upward to named <br /></td></tr>
<tr class="separator:a6d2b95a4802d2a4fc33b556726e0656f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5198433016d177ca57f4c24c3427eca"><td class="memItemLeft" align="right" valign="top"><a id="ac5198433016d177ca57f4c24c3427eca"></a>
virtual <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; node, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#ac5198433016d177ca57f4c24c3427eca">get_node</a> ()</td></tr>
<tr class="memdesc:ac5198433016d177ca57f4c24c3427eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast upward to node <br /></td></tr>
<tr class="separator:ac5198433016d177ca57f4c24c3427eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6c94f5eb8784c955f687984cbb70ae"><td class="memItemLeft" align="right" valign="top"><a id="acd6c94f5eb8784c955f687984cbb70ae"></a>
virtual <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; group, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#acd6c94f5eb8784c955f687984cbb70ae">get_group</a> ()</td></tr>
<tr class="memdesc:acd6c94f5eb8784c955f687984cbb70ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast upward to group <br /></td></tr>
<tr class="separator:acd6c94f5eb8784c955f687984cbb70ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465d1e143a091da84a346ea011b9af7b"><td class="memTemplParams" colspan="2"><a id="a465d1e143a091da84a346ea011b9af7b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a465d1e143a091da84a346ea011b9af7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; T, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a465d1e143a091da84a346ea011b9af7b">cast</a> ()</td></tr>
<tr class="memdesc:a465d1e143a091da84a346ea011b9af7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast to arbitrary class, but use the casts to named, node and group from the interface <br /></td></tr>
<tr class="separator:a465d1e143a091da84a346ea011b9af7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b866151a23c63b3e8029849e71a796"><td class="memTemplParams" colspan="2"><a id="aa2b866151a23c63b3e8029849e71a796"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa2b866151a23c63b3e8029849e71a796"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#aa2b866151a23c63b3e8029849e71a796">get_interface</a> ()</td></tr>
<tr class="memdesc:aa2b866151a23c63b3e8029849e71a796"><td class="mdescLeft">&#160;</td><td class="mdescRight">use dynamic type cast to check for the given interface <br /></td></tr>
<tr class="separator:aa2b866151a23c63b3e8029849e71a796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322bdd4891db870dafaba22e40d99bff"><td class="memTemplParams" colspan="2"><a id="a322bdd4891db870dafaba22e40d99bff"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a322bdd4891db870dafaba22e40d99bff"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a322bdd4891db870dafaba22e40d99bff">get_const_interface</a> () const</td></tr>
<tr class="memdesc:a322bdd4891db870dafaba22e40d99bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">use dynamic type cast to check for the given interface <br /></td></tr>
<tr class="separator:a322bdd4891db870dafaba22e40d99bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1dd0ff6fa2baf3dc2149d3acfecd45"><td class="memItemLeft" align="right" valign="top"><a id="a3e1dd0ff6fa2baf3dc2149d3acfecd45"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a3e1dd0ff6fa2baf3dc2149d3acfecd45">update</a> ()</td></tr>
<tr class="memdesc:a3e1dd0ff6fa2baf3dc2149d3acfecd45"><td class="mdescLeft">&#160;</td><td class="mdescRight">this virtual update allows for example to ask a view to update the viewed value. The default implementation is empty. <br /></td></tr>
<tr class="separator:a3e1dd0ff6fa2baf3dc2149d3acfecd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed62898813a55528e2b4c2c9e57cdf15"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#aed62898813a55528e2b4c2c9e57cdf15">get_user_data</a> () const</td></tr>
<tr class="memdesc:aed62898813a55528e2b4c2c9e57cdf15"><td class="mdescLeft">&#160;</td><td class="mdescRight">this virtual method allows to pass application specific data for internal purposes  <a href="classcgv_1_1base_1_1base.html#aed62898813a55528e2b4c2c9e57cdf15">More...</a><br /></td></tr>
<tr class="separator:aed62898813a55528e2b4c2c9e57cdf15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b5dba890a068acef62d9c026c05320"><td class="memItemLeft" align="right" valign="top"><a id="a67b5dba890a068acef62d9c026c05320"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1data_1_1ref__counted.html#a67b5dba890a068acef62d9c026c05320">get_ref_count</a> () const</td></tr>
<tr class="memdesc:a67b5dba890a068acef62d9c026c05320"><td class="mdescLeft">&#160;</td><td class="mdescRight">read access to current count <br /></td></tr>
<tr class="separator:a67b5dba890a068acef62d9c026c05320"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:abceffe95f08d3fc13cf9286cf360e705"><td class="memItemLeft" align="right" valign="top"><a id="abceffe95f08d3fc13cf9286cf360e705"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1data_1_1ref__counted.html#abceffe95f08d3fc13cf9286cf360e705">set_ref_count</a> (int c) const</td></tr>
<tr class="memdesc:abceffe95f08d3fc13cf9286cf360e705"><td class="mdescLeft">&#160;</td><td class="mdescRight">write access is also const to allow ref counted pointers to const instances <br /></td></tr>
<tr class="separator:abceffe95f08d3fc13cf9286cf360e705"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ad8d0e6ffe70e6d8adc43876dfca2e84a"><td class="memTemplParams" colspan="2"><a id="ad8d0e6ffe70e6d8adc43876dfca2e84a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad8d0e6ffe70e6d8adc43876dfca2e84a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; T, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#ad8d0e6ffe70e6d8adc43876dfca2e84a">cast_dynamic</a> (base *b)</td></tr>
<tr class="memdesc:ad8d0e6ffe70e6d8adc43876dfca2e84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">use dynamic cast for upcast to given class <br /></td></tr>
<tr class="separator:ad8d0e6ffe70e6d8adc43876dfca2e84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
property interface</h2></td></tr>
<tr class="memitem:aa0fe4266b74ebe49de68faaab3ca7a7a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#aa0fe4266b74ebe49de68faaab3ca7a7a">self_reflect</a> (<a class="el" href="classcgv_1_1reflect_1_1reflection__handler.html">cgv::reflect::reflection_handler</a> &amp;)</td></tr>
<tr class="memdesc:aa0fe4266b74ebe49de68faaab3ca7a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">used for simple self reflection  <a href="classcgv_1_1base_1_1base.html#aa0fe4266b74ebe49de68faaab3ca7a7a">More...</a><br /></td></tr>
<tr class="separator:aa0fe4266b74ebe49de68faaab3ca7a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d67c8d339fe06f17396aaa8625292f8"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a4d67c8d339fe06f17396aaa8625292f8">get_property_declarations</a> ()</td></tr>
<tr class="memdesc:a4d67c8d339fe06f17396aaa8625292f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a semicolon separated list of property declarations  <a href="classcgv_1_1base_1_1base.html#a4d67c8d339fe06f17396aaa8625292f8">More...</a><br /></td></tr>
<tr class="separator:a4d67c8d339fe06f17396aaa8625292f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d3cd5ae49c3e261f5c0e52bc59bd4f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a62d3cd5ae49c3e261f5c0e52bc59bd4f">set_void</a> (const std::string &amp;property, const std::string &amp;value_type, const void *value_ptr)</td></tr>
<tr class="memdesc:a62d3cd5ae49c3e261f5c0e52bc59bd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract interface for the setter of a dynamic property.  <a href="classcgv_1_1base_1_1base.html#a62d3cd5ae49c3e261f5c0e52bc59bd4f">More...</a><br /></td></tr>
<tr class="separator:a62d3cd5ae49c3e261f5c0e52bc59bd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d54b3a4cef6b98b98b0d97d41cad410"><td class="memItemLeft" align="right" valign="top"><a id="a6d54b3a4cef6b98b98b0d97d41cad410"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a6d54b3a4cef6b98b98b0d97d41cad410">on_set</a> (void *member_ptr)</td></tr>
<tr class="memdesc:a6d54b3a4cef6b98b98b0d97d41cad410"><td class="mdescLeft">&#160;</td><td class="mdescRight">this callback is called when the set_void method has changed a member and can be overloaded in derived class <br /></td></tr>
<tr class="separator:a6d54b3a4cef6b98b98b0d97d41cad410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0cf2e6e9275472854996435e25fe17"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#aec0cf2e6e9275472854996435e25fe17">get_void</a> (const std::string &amp;property, const std::string &amp;value_type, void *value_ptr)</td></tr>
<tr class="memdesc:aec0cf2e6e9275472854996435e25fe17"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract interface for the getter of a dynamic property.  <a href="classcgv_1_1base_1_1base.html#aec0cf2e6e9275472854996435e25fe17">More...</a><br /></td></tr>
<tr class="separator:aec0cf2e6e9275472854996435e25fe17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6746cd9f70fefe5a4f2b72534869fcc3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a6746cd9f70fefe5a4f2b72534869fcc3">call_void</a> (const std::string &amp;method, const std::vector&lt; std::string &gt; &amp;param_value_types, const std::vector&lt; const void * &gt; &amp;param_value_ptrs, const std::string &amp;result_type=&quot;&quot;, void *result_value_ptr=0)</td></tr>
<tr class="memdesc:a6746cd9f70fefe5a4f2b72534869fcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract interface to call an action  <a href="classcgv_1_1base_1_1base.html#a6746cd9f70fefe5a4f2b72534869fcc3">More...</a><br /></td></tr>
<tr class="separator:a6746cd9f70fefe5a4f2b72534869fcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff38549b7f5c57918898543e78a416d"><td class="memItemLeft" align="right" valign="top"><a id="a1ff38549b7f5c57918898543e78a416d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a1ff38549b7f5c57918898543e78a416d">set</a> (const std::string &amp;property, const char *value)</td></tr>
<tr class="memdesc:a1ff38549b7f5c57918898543e78a416d"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialization of set method to support const char* as strings <br /></td></tr>
<tr class="separator:a1ff38549b7f5c57918898543e78a416d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1b6b56455165d769b580d4006eba17"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd1b6b56455165d769b580d4006eba17"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#abd1b6b56455165d769b580d4006eba17">set</a> (const std::string &amp;property, const T &amp;value)</td></tr>
<tr class="memdesc:abd1b6b56455165d769b580d4006eba17"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a property of the element to the given value and perform standard conversions if necessary.  <a href="classcgv_1_1base_1_1base.html#abd1b6b56455165d769b580d4006eba17">More...</a><br /></td></tr>
<tr class="separator:abd1b6b56455165d769b580d4006eba17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5978e45464c3fdd3083426c4b21ed28a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5978e45464c3fdd3083426c4b21ed28a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#a5978e45464c3fdd3083426c4b21ed28a">get</a> (const std::string &amp;property)</td></tr>
<tr class="memdesc:a5978e45464c3fdd3083426c4b21ed28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">query a property of the element and perform standard conversions if necessary.  <a href="classcgv_1_1base_1_1base.html#a5978e45464c3fdd3083426c4b21ed28a">More...</a><br /></td></tr>
<tr class="separator:a5978e45464c3fdd3083426c4b21ed28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfaded48bb322a4b77350ca73c9e1a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#afbfaded48bb322a4b77350ca73c9e1a2">multi_set</a> (const std::string &amp;property_assignments, bool report_error=true)</td></tr>
<tr class="memdesc:afbfaded48bb322a4b77350ca73c9e1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">set several properties  <a href="classcgv_1_1base_1_1base.html#afbfaded48bb322a4b77350ca73c9e1a2">More...</a><br /></td></tr>
<tr class="separator:afbfaded48bb322a4b77350ca73c9e1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad796aa58a0b7d9c52d724a99366f58ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#ad796aa58a0b7d9c52d724a99366f58ae">is_property</a> (const std::string &amp;property_name, std::string *<a class="el" href="structcgv_1_1type_1_1info_1_1type__name.html">type_name</a>=0)</td></tr>
<tr class="memdesc:ad796aa58a0b7d9c52d724a99366f58ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if the given name specifies a property.  <a href="classcgv_1_1base_1_1base.html#ad796aa58a0b7d9c52d724a99366f58ae">More...</a><br /></td></tr>
<tr class="separator:ad796aa58a0b7d9c52d724a99366f58ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad121ecb072de62a4ab4a180bc9d183bb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html#ad121ecb072de62a4ab4a180bc9d183bb">find_member_ptr</a> (const std::string &amp;property_name, std::string *<a class="el" href="structcgv_1_1type_1_1info_1_1type__name.html">type_name</a>=0)</td></tr>
<tr class="memdesc:ad121ecb072de62a4ab4a180bc9d183bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">find a member pointer by name.  <a href="classcgv_1_1base_1_1base.html#ad121ecb072de62a4ab4a180bc9d183bb">More...</a><br /></td></tr>
<tr class="separator:ad121ecb072de62a4ab4a180bc9d183bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>abstract interface for image readers </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a6746cd9f70fefe5a4f2b72534869fcc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6746cd9f70fefe5a4f2b72534869fcc3">&#9670;&nbsp;</a></span>call_void()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::base::base::call_void </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>param_value_types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>param_value_ptrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>result_type</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>result_value_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>abstract interface to call an action </p>
<p>overload to implement the execution of a method based on the method name and the given parameters</p>
<p>, i.e. a class method based on the action name and the given parameters. The default implementation uses the <a class="el" href="classcgv_1_1base_1_1base.html#aa0fe4266b74ebe49de68faaab3ca7a7a" title="used for simple self reflection">self_reflect()</a> method to dispatch this call. If not found, the get_void method returns false. </p>

</div>
</div>
<a id="ad121ecb072de62a4ab4a180bc9d183bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad121ecb072de62a4ab4a180bc9d183bb">&#9670;&nbsp;</a></span>find_member_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * cgv::base::base::find_member_ptr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>type_name</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find a member pointer by name. </p>
<p>If not found the null pointer is returned. If the type name string pointer is provided, the type of the property is copied to the referenced string. </p>

</div>
</div>
<a id="a5978e45464c3fdd3083426c4b21ed28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5978e45464c3fdd3083426c4b21ed28a">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T cgv::base::base::get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>query a property of the element and perform standard conversions if necessary. </p>
<p>This templated version simply extracts the type of the value from the reference and calls the <a class="el" href="classcgv_1_1base_1_1base.html#a62d3cd5ae49c3e261f5c0e52bc59bd4f" title="abstract interface for the setter of a dynamic property.">set_void()</a> method. Note that this only works if the template cgv::type::info::type_name&lt;T&gt; is overloaded for the value type. </p>

</div>
</div>
<a id="a1c1a2ab5612d425e69373e8ad66e69c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1a2ab5612d425e69373e8ad66e69c9">&#9670;&nbsp;</a></span>get_image_duration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cgv::media::image::abst_image_reader::get_image_duration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the duration of the current image in seconds, if returned value is 0, no duration is available </p>
<p>return the duration of the current image in seconds </p>

</div>
</div>
<a id="a4d67c8d339fe06f17396aaa8625292f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d67c8d339fe06f17396aaa8625292f8">&#9670;&nbsp;</a></span>get_property_declarations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string cgv::base::base::get_property_declarations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a semicolon separated list of property declarations </p>
<p>return a semicolon separated list of property declarations of the form "name:type", by default an empty list is returned</p>
<p>of the form "name1:type1;name2:type2;...", by default an empty list is returned. The types should by consistent with the names returned by <a class="el" href="structcgv_1_1type_1_1info_1_1type__name.html#a7dcb7c43dbf01bd9276508eb7e2295aa" title="return special name for standard types or type name from RTTI cleaned from keywords for all other typ...">cgv::type::info::type_name::get_name</a>. The default implementation extracts names and types from the <a class="el" href="classcgv_1_1base_1_1base.html#aa0fe4266b74ebe49de68faaab3ca7a7a" title="used for simple self reflection">self_reflect()</a> method and the meta type information provided by the get_type() method. </p>

<p>Reimplemented in <a class="el" href="structcgv_1_1base_1_1factory.html#a614db734b9dab12958b6c0370addfb6f">cgv::base::factory</a>, <a class="el" href="classcgv_1_1base_1_1base__generator.html#a398375938ddac0a608e2fcaa96240623">cgv::base::base_generator</a>, <a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#ae6cd9178f2412fcc7e3068cf76cb1611">cgv::media::image::image_reader</a>, <a class="el" href="classcgv_1_1media_1_1video_1_1video__writer.html#a70c7d0a47fedc21d9da8ae58a8e582b2">cgv::media::video::video_writer</a>, <a class="el" href="classcgv_1_1media_1_1image_1_1image__writer.html#a477ec6f721fcae426557c6f6584cf134">cgv::media::image::image_writer</a>, <a class="el" href="classcgv_1_1media_1_1video_1_1video__reader.html#aa79161bb56539ef00192c01887e91026">cgv::media::video::video_reader</a>, and <a class="el" href="classcgv_1_1base_1_1console.html#a662798821c197e8886aff79e8ffa3d40">cgv::base::console</a>.</p>

</div>
</div>
<a id="a6e64a898476591f7246e522652abfa4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e64a898476591f7246e522652abfa4c">&#9670;&nbsp;</a></span>get_type_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string cgv::base::base::get_type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload to return the type name of this object. By default the type interface is queried over get_type. </p>
<p>overload to return the type name of this object </p>

<p>Reimplemented in <a class="el" href="structcgv_1_1render_1_1render__config.html#ac961620d05cc3e086bc1e6a1632feff1">cgv::render::render_config</a>, <a class="el" href="classcgv_1_1base_1_1test.html#a0b82b40213f0c7e52b9079958d21c430">cgv::base::test</a>, <a class="el" href="structcgv_1_1base_1_1factory__impl__2.html#ab0cb1553fde097b63c82309b74954b89">cgv::base::factory_impl_2&lt; T, CA1, CA2 &gt;</a>, <a class="el" href="structcgv_1_1base_1_1factory__impl__1.html#ae8d8ca1142c33e11db79395fd85047a4">cgv::base::factory_impl_1&lt; T, CA &gt;</a>, <a class="el" href="structcgv_1_1base_1_1factory__impl.html#a3f5649e886cde97647a03b6c8b68e925">cgv::base::factory_impl&lt; T &gt;</a>, <a class="el" href="structcgv_1_1base_1_1object__constructor.html#a072d77dbad3f324928ef35de4674f13c">cgv::base::object_constructor</a>, <a class="el" href="classcgv_1_1base_1_1base__generator.html#a6e2ed9978aa7b6b765533e3b55f1d378">cgv::base::base_generator</a>, <a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#ab06b7ffbf23bf2af4914da0b8db85ce6">cgv::media::image::image_reader</a>, <a class="el" href="classcgv_1_1media_1_1video_1_1video__writer.html#a879a54ea45fdf41a1a7c878228bd19d7">cgv::media::video::video_writer</a>, <a class="el" href="classcgv_1_1media_1_1image_1_1image__writer.html#ad54b65e5a1edbdb6dd747705d3520cb5">cgv::media::image::image_writer</a>, <a class="el" href="classcgv_1_1media_1_1font_1_1font.html#a441fe39612572d392a8785fdb928581c">cgv::media::font::font</a>, <a class="el" href="structcgv_1_1media_1_1image_1_1reader__listener.html#aa0f43edbbea52853cd5cdfbd31778e85">cgv::media::image::reader_listener</a>, <a class="el" href="classcgv_1_1media_1_1video_1_1video__reader.html#ac37649d0d608cee9005cea455396d3e3">cgv::media::video::video_reader</a>, <a class="el" href="classcgv_1_1gui_1_1gui__group.html#a072c0b97c3dd0d0b3aea1b0811010658">cgv::gui::gui_group</a>, <a class="el" href="classcgv_1_1base_1_1group.html#abbc7567d9b3cc7fe66d5d8ef01a2a773">cgv::base::group</a>, <a class="el" href="structcgv_1_1media_1_1video_1_1video__writer__listener.html#a7539b5708c83248ffbad8b568a8af81e">cgv::media::video::video_writer_listener</a>, <a class="el" href="classcgv_1_1media_1_1font_1_1font__face.html#ae04d754503d4aac853781bee0f0e0af0">cgv::media::font::font_face</a>, <a class="el" href="classcgv_1_1base_1_1node.html#ab135d52af631a979c9142fa6e6277eff">cgv::base::node</a>, <a class="el" href="classcgv_1_1base_1_1named.html#ae41ed4f3235a1e88b16b30286f0ab740">cgv::base::named</a>, <a class="el" href="classcgv_1_1base_1_1console.html#a39a260eaf1d10ad36a1a6fa97a9bdd14">cgv::base::console</a>, <a class="el" href="classcgv_1_1media_1_1image_1_1bmp__reader.html#a1e0102f692546901a3db7c7523320e3a">cgv::media::image::bmp_reader</a>, <a class="el" href="structcgv_1_1media_1_1video_1_1video__reader__listener.html#a0fe4a691782c28b859d98d86c23d2e06">cgv::media::video::video_reader_listener</a>, <a class="el" href="classcgv_1_1media_1_1image_1_1bmp__writer.html#a60cd590aa367b86562103e9c903de5c1">cgv::media::image::bmp_writer</a>, <a class="el" href="structcgv_1_1media_1_1image_1_1writer__listener.html#ad18693edf244be2f8e657582be2f7591">cgv::media::image::writer_listener</a>, <a class="el" href="classcgv_1_1gui_1_1window.html#abfac998925c78b8d27656afe51faf9bd">cgv::gui::window</a>, and <a class="el" href="classcgv_1_1gui_1_1button.html#a827c7544196613c0cf56d2bf1d9067cd">cgv::gui::button</a>.</p>

</div>
</div>
<a id="aed62898813a55528e2b4c2c9e57cdf15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed62898813a55528e2b4c2c9e57cdf15">&#9670;&nbsp;</a></span>get_user_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * cgv::base::base::get_user_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this virtual method allows to pass application specific data for internal purposes </p>
<p>this virtual method allows derived classes to pass application specific data </p>

</div>
</div>
<a id="aec0cf2e6e9275472854996435e25fe17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0cf2e6e9275472854996435e25fe17">&#9670;&nbsp;</a></span>get_void()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::base::base::get_void </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>abstract interface for the getter of a dynamic property. </p>
<p>abstract interface for the getter, by default it simply returns false</p>
<p>The default implementation uses the <a class="el" href="classcgv_1_1base_1_1base.html#aa0fe4266b74ebe49de68faaab3ca7a7a" title="used for simple self reflection">self_reflect()</a> method to find a member with the given property as name. If not found, the get_void method returns false. </p>

<p>Reimplemented in <a class="el" href="structcgv_1_1base_1_1factory.html#aa4d907250a697d6c8368140133c9d719">cgv::base::factory</a>, <a class="el" href="classcgv_1_1base_1_1base__generator.html#abfaaedd0749b1123dd7f320a13600027">cgv::base::base_generator</a>, <a class="el" href="classcgv_1_1base_1_1console.html#a122730d2bac682abd6213b355f7d95b5">cgv::base::console</a>, <a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#aa96a1e4519bc87a517b5149ba27095e0">cgv::media::image::image_reader</a>, <a class="el" href="classcgv_1_1media_1_1image_1_1image__writer.html#aa6627b8b8595bbb75cb3e9f45839fa08">cgv::media::image::image_writer</a>, <a class="el" href="classcgv_1_1media_1_1video_1_1video__reader.html#a0bd18953a4ce256e940177c643fca639">cgv::media::video::video_reader</a>, and <a class="el" href="classcgv_1_1media_1_1video_1_1video__writer.html#a90f05725f03c58306d1d3a35157517c4">cgv::media::video::video_writer</a>.</p>

</div>
</div>
<a id="ad796aa58a0b7d9c52d724a99366f58ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad796aa58a0b7d9c52d724a99366f58ae">&#9670;&nbsp;</a></span>is_property()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::base::base::is_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>type_name</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if the given name specifies a property. </p>
<p>If the type name string pointer is provided, the type of the property is copied to the referenced string. </p>

</div>
</div>
<a id="afbfaded48bb322a4b77350ca73c9e1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfaded48bb322a4b77350ca73c9e1a2">&#9670;&nbsp;</a></span>multi_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgv::base::base::multi_set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property_assignments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>report_error</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set several properties </p>
<p>set several properties, which are defined as colon separated assignments, where the types are derived automatically</p>
<p>, which are defined as colon separated assignments, where the types are derived automatically to bool, int, double or std::string. </p>

</div>
</div>
<a id="a2f074aea5bf4b0bfeb00845750d27623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f074aea5bf4b0bfeb00845750d27623">&#9670;&nbsp;</a></span>on_register()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgv::base::base::on_register </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload to handle register events that is sent after the instance has been registered </p>
<p>overload to return a type info structure. By default an empty pointer is returned. </p>

</div>
</div>
<a id="af3811feeb4f9c0c1b50e6985764af9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3811feeb4f9c0c1b50e6985764af9bf">&#9670;&nbsp;</a></span>read_image()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cgv::media::image::abst_image_reader::read_image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1data_1_1data__format.html">data_format</a> &amp;&#160;</td>
          <td class="paramname"><em>df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &amp;&#160;</td>
          <td class="paramname"><em>dv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>read an image into the given data pointer. </p>
<p>Only possible after successful open. If multiple images are contained in the file, this method can be called with success once for each contained image. The number of images can be determined despite of the method <code><a class="el" href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#ad823ad70517819be61b46476248c014e" title="return the number of images in the file, what can cause the whole file to be scanned">get_nr_images()</a></code> by calling this method until it returns false. </p>

<p>Implemented in <a class="el" href="classcgv_1_1media_1_1image_1_1bmp__reader.html#a064688f5c860af22bae737b0b19b1c13">cgv::media::image::bmp_reader</a>.</p>

</div>
</div>
<a id="af87eb9fee9edaf1814c66bd625d16ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87eb9fee9edaf1814c66bd625d16ec9">&#9670;&nbsp;</a></span>read_palette()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::media::image::abst_image_reader::read_palette </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcgv_1_1data_1_1data__view.html">data_view</a> &amp;&#160;</td>
          <td class="paramname"><em>dv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>read the i-th palette in case of a paletted file format, the standard implementation returns false </p>
<p>In case of files with animated images, the palette can change for each image. Therefore call this method before each call to <code><a class="el" href="classcgv_1_1media_1_1image_1_1abst__image__reader.html#af3811feeb4f9c0c1b50e6985764af9bf" title="read an image into the given data pointer.">read_image()</a></code>. </p>

<p>Reimplemented in <a class="el" href="classcgv_1_1media_1_1image_1_1bmp__reader.html#a24e6fef57a43ce497bd37804c0d9d9de">cgv::media::image::bmp_reader</a>.</p>

</div>
</div>
<a id="aa0fe4266b74ebe49de68faaab3ca7a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0fe4266b74ebe49de68faaab3ca7a7a">&#9670;&nbsp;</a></span>self_reflect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::base::base::self_reflect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcgv_1_1reflect_1_1reflection__handler.html">cgv::reflect::reflection_handler</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>used for simple self reflection </p>
<p>is used by default implementation of set_void, get_void and get_property_declarations</p>
<p>The overloaded implementation is used by the default implementations of set_void, get_void and get_property_declarations with corresponding reflection handlers. The default implementation of self_reflect is empty. </p>

<p>Reimplemented in <a class="el" href="structcgv_1_1render_1_1render__config.html#a91eabc5d1bee4696cce6de5ad05dfbe8">cgv::render::render_config</a>.</p>

</div>
</div>
<a id="abd1b6b56455165d769b580d4006eba17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1b6b56455165d769b580d4006eba17">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgv::base::base::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set a property of the element to the given value and perform standard conversions if necessary. </p>
<p>This templated version simply extracts the type of the value from the reference and calls the <a class="el" href="classcgv_1_1base_1_1base.html#a62d3cd5ae49c3e261f5c0e52bc59bd4f" title="abstract interface for the setter of a dynamic property.">set_void()</a> method. Note that this only works if the template cgv::type::info::type_name&lt;T&gt; is overloaded for the value type. </p>

</div>
</div>
<a id="a62d3cd5ae49c3e261f5c0e52bc59bd4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d3cd5ae49c3e261f5c0e52bc59bd4f">&#9670;&nbsp;</a></span>set_void()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::base::base::set_void </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>abstract interface for the setter of a dynamic property. </p>
<p>abstract interface for the setter, by default it simply returns false</p>
<p>The default implementation uses the <a class="el" href="classcgv_1_1base_1_1base.html#aa0fe4266b74ebe49de68faaab3ca7a7a" title="used for simple self reflection">self_reflect()</a> method to find a member with the given property as name. If not found, the set_void method returns false. </p>

<p>Reimplemented in <a class="el" href="structcgv_1_1base_1_1factory.html#a03229b698d12d0da2cae1b769f0ee40e">cgv::base::factory</a>, <a class="el" href="classcgv_1_1base_1_1base__generator.html#aa69ce6781528ebf7f78412fd6c7bad5f">cgv::base::base_generator</a>, <a class="el" href="classcgv_1_1base_1_1console.html#a99ea2f5fa87e80338b1f996de9dc6983">cgv::base::console</a>, <a class="el" href="classcgv_1_1media_1_1image_1_1image__reader.html#aa31653a404d2100655e91db9c00cfda1">cgv::media::image::image_reader</a>, <a class="el" href="classcgv_1_1media_1_1image_1_1image__writer.html#a2eeade9ca2755e97f55e1f162bf495b7">cgv::media::image::image_writer</a>, <a class="el" href="classcgv_1_1media_1_1video_1_1video__reader.html#a702b054c51a69f3d1b982a14c99282d6">cgv::media::video::video_reader</a>, and <a class="el" href="classcgv_1_1media_1_1video_1_1video__writer.html#afd0800ba2f918dc95b8a3ce2a26978ed">cgv::media::video::video_writer</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>cgv/media/image/<a class="el" href="image__reader_8h_source.html">image_reader.h</a></li>
<li>cgv/media/image/image_reader.cxx</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecgv.html">cgv</a></li><li class="navelem"><b>media</b></li><li class="navelem"><a class="el" href="namespacecgv_1_1media_1_1image.html">image</a></li><li class="navelem"><a class="el" href="classcgv_1_1media_1_1image_1_1abst__image__reader.html">abst_image_reader</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
