<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>cgv: cgv::gui::provider Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cgv
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00096.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="a00914.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cgv::gui::provider Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>derive from this class to provide a gui to the current viewer  
 <a href="a00096.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00590_source.html">provider.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cgv::gui::provider:</div>
<div class="dyncontent">
<div class="center"><img src="a00915.png" border="0" usemap="#cgv_1_1gui_1_1provider_inherit__map" alt="Inheritance graph"/></div>
<map name="cgv_1_1gui_1_1provider_inherit__map" id="cgv_1_1gui_1_1provider_inherit__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for cgv::gui::provider:</div>
<div class="dyncontent">
<div class="center"><img src="a00916.png" border="0" usemap="#cgv_1_1gui_1_1provider_coll__map" alt="Collaboration graph"/></div>
<map name="cgv_1_1gui_1_1provider_coll__map" id="cgv_1_1gui_1_1provider_coll__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab3f328865e01ce1faaadedbf7a83e429"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3f328865e01ce1faaadedbf7a83e429"></a>
<a class="el" href="a00710.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#ab3f328865e01ce1faaadedbf7a83e429">get_parent_group</a> () const </td></tr>
<tr class="memdesc:ab3f328865e01ce1faaadedbf7a83e429"><td class="mdescLeft">&#160;</td><td class="mdescRight">use the parent group to append to be managed elements that should be destroyed in a post_recreate_gui event <br /></td></tr>
<tr class="separator:ab3f328865e01ce1faaadedbf7a83e429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e631f03ab8c729b5a97ef9effc0df4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56e631f03ab8c729b5a97ef9effc0df4"></a>
<a class="el" href="a00710.html#aceb07fba6859effc2353f70788dd7f9b">view_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#a56e631f03ab8c729b5a97ef9effc0df4">add_view_void</a> (const std::string &amp;label, const void *value_ptr, const std::string &amp;value_type, const std::string &amp;gui_type, const std::string &amp;options, const std::string &amp;<a class="el" href="a00096.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>)</td></tr>
<tr class="memdesc:a56e631f03ab8c729b5a97ef9effc0df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a newly created view to the group <br /></td></tr>
<tr class="separator:a56e631f03ab8c729b5a97ef9effc0df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaee067e53371e254a7e8a2ae6e0dd72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abaee067e53371e254a7e8a2ae6e0dd72"></a>
<a class="el" href="a00710.html#aebf3fd94311cb8a2bcffb4634f1e73b1">control_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#abaee067e53371e254a7e8a2ae6e0dd72">add_control_void</a> (const std::string &amp;label, void *value_ptr, <a class="el" href="a00079.html">abst_control_provider</a> *acp, const std::string &amp;value_type, const std::string &amp;gui_type, const std::string &amp;options, const std::string &amp;<a class="el" href="a00096.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>, void *user_data)</td></tr>
<tr class="memdesc:abaee067e53371e254a7e8a2ae6e0dd72"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a newly created control to the group <br /></td></tr>
<tr class="separator:abaee067e53371e254a7e8a2ae6e0dd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6807d6d7fff24fd1d895cf67fd3e1331"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6807d6d7fff24fd1d895cf67fd3e1331"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#a6807d6d7fff24fd1d895cf67fd3e1331">provider</a> ()</td></tr>
<tr class="memdesc:a6807d6d7fff24fd1d895cf67fd3e1331"><td class="mdescLeft">&#160;</td><td class="mdescRight">default construction <br /></td></tr>
<tr class="separator:a6807d6d7fff24fd1d895cf67fd3e1331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c059c10d5b754e7e8ca02be639bead6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c059c10d5b754e7e8ca02be639bead6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#a7c059c10d5b754e7e8ca02be639bead6">~provider</a> ()</td></tr>
<tr class="memdesc:a7c059c10d5b754e7e8ca02be639bead6"><td class="mdescLeft">&#160;</td><td class="mdescRight">ensure to remove posted recreation callbacks <br /></td></tr>
<tr class="separator:a7c059c10d5b754e7e8ca02be639bead6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed7b09695efb1d3ea4072ab355e41fa"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#a2ed7b09695efb1d3ea4072ab355e41fa">get_gui_name</a> () const </td></tr>
<tr class="memdesc:a2ed7b09695efb1d3ea4072ab355e41fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derive a name for this instance that can be used in the gui as heading.  <a href="#a2ed7b09695efb1d3ea4072ab355e41fa">More...</a><br /></td></tr>
<tr class="separator:a2ed7b09695efb1d3ea4072ab355e41fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c795cd30d68706c3aac1d2abc1f9d7"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#ad8c795cd30d68706c3aac1d2abc1f9d7">get_parent_type</a> () const </td></tr>
<tr class="memdesc:ad8c795cd30d68706c3aac1d2abc1f9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the group type that should be used by the class embedding the gui of the provider.  <a href="#ad8c795cd30d68706c3aac1d2abc1f9d7">More...</a><br /></td></tr>
<tr class="separator:ad8c795cd30d68706c3aac1d2abc1f9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841e8ef471bf376be1c3fa97179cd218"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a841e8ef471bf376be1c3fa97179cd218"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#a841e8ef471bf376be1c3fa97179cd218">update_member</a> (void *member_ptr)</td></tr>
<tr class="memdesc:a841e8ef471bf376be1c3fa97179cd218"><td class="mdescLeft">&#160;</td><td class="mdescRight">call this to update all views and controls of a member <br /></td></tr>
<tr class="separator:a841e8ef471bf376be1c3fa97179cd218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f205b0f9fb19663ded86d329a88678"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54f205b0f9fb19663ded86d329a88678"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#a54f205b0f9fb19663ded86d329a88678">update_all_members</a> ()</td></tr>
<tr class="memdesc:a54f205b0f9fb19663ded86d329a88678"><td class="mdescLeft">&#160;</td><td class="mdescRight">call this to update all views and controls of all member <br /></td></tr>
<tr class="separator:a54f205b0f9fb19663ded86d329a88678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39610a27c1eef83fd785e52ba11c726c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39610a27c1eef83fd785e52ba11c726c"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#a39610a27c1eef83fd785e52ba11c726c">get_menu_path</a> () const </td></tr>
<tr class="memdesc:a39610a27c1eef83fd785e52ba11c726c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a path in the main menu to select the gui <br /></td></tr>
<tr class="separator:a39610a27c1eef83fd785e52ba11c726c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f33a940b4280f41bc30efe72717fb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30f33a940b4280f41bc30efe72717fb9"></a>
virtual <a class="el" href="a00097.html">shortcut</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#a30f33a940b4280f41bc30efe72717fb9">get_shortcut</a> () const </td></tr>
<tr class="memdesc:a30f33a940b4280f41bc30efe72717fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a shortcut to activate the gui without menu navigation <br /></td></tr>
<tr class="separator:a30f33a940b4280f41bc30efe72717fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2f0b6c734c04d3c90a1c51ffbc0de9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d2f0b6c734c04d3c90a1c51ffbc0de9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#a1d2f0b6c734c04d3c90a1c51ffbc0de9">create_gui</a> ()=0</td></tr>
<tr class="memdesc:a1d2f0b6c734c04d3c90a1c51ffbc0de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">you must overload this for gui creation <br /></td></tr>
<tr class="separator:a1d2f0b6c734c04d3c90a1c51ffbc0de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71df33b57067886a8c264ed9eb672f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#ab71df33b57067886a8c264ed9eb672f5">recreate_gui</a> ()</td></tr>
<tr class="memdesc:ab71df33b57067886a8c264ed9eb672f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recreate the gui of this instance right now.  <a href="#ab71df33b57067886a8c264ed9eb672f5">More...</a><br /></td></tr>
<tr class="separator:ab71df33b57067886a8c264ed9eb672f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91a5b7508ca2f8a995a7101a80cab76"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#aa91a5b7508ca2f8a995a7101a80cab76">post_recreate_gui</a> ()</td></tr>
<tr class="memdesc:aa91a5b7508ca2f8a995a7101a80cab76"><td class="mdescLeft">&#160;</td><td class="mdescRight">delayed recreation of gui  <a href="#aa91a5b7508ca2f8a995a7101a80cab76">More...</a><br /></td></tr>
<tr class="separator:aa91a5b7508ca2f8a995a7101a80cab76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">creation of gui</div></td></tr>
<tr class="memitem:a28af4e659bdd1825f3829263e15ce5ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28af4e659bdd1825f3829263e15ce5ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#a28af4e659bdd1825f3829263e15ce5ae">align</a> (const std::string &amp;_align)</td></tr>
<tr class="memdesc:a28af4e659bdd1825f3829263e15ce5ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">send pure alignment information <br /></td></tr>
<tr class="separator:a28af4e659bdd1825f3829263e15ce5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f82aa4b9a568ca39bff1c1fa2fc637a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00710.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#a4f82aa4b9a568ca39bff1c1fa2fc637a">add_object_gui</a> (base_ptr object, const std::string &amp;label, const std::string &amp;group_type, const std::string &amp;options, const std::string &amp;<a class="el" href="a00096.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>)</td></tr>
<tr class="memdesc:a4f82aa4b9a568ca39bff1c1fa2fc637a"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a new group to the given parent group, not supported yet  <a href="#a4f82aa4b9a568ca39bff1c1fa2fc637a">More...</a><br /></td></tr>
<tr class="separator:a4f82aa4b9a568ca39bff1c1fa2fc637a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d293603edad6ffd9a84303f67d6060a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d293603edad6ffd9a84303f67d6060a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#a6d293603edad6ffd9a84303f67d6060a">inline_object_gui</a> (base_ptr object)</td></tr>
<tr class="memdesc:a6d293603edad6ffd9a84303f67d6060a"><td class="mdescLeft">&#160;</td><td class="mdescRight">inline the gui of another object that must be derived from provider. <br /></td></tr>
<tr class="separator:a6d293603edad6ffd9a84303f67d6060a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79595103df6c363aba76db5ce49312ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79595103df6c363aba76db5ce49312ce"></a>
<a class="el" href="a00710.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#a79595103df6c363aba76db5ce49312ce">add_group</a> (const std::string &amp;label, const std::string &amp;group_type, const std::string &amp;options=&quot;&quot;, const std::string &amp;<a class="el" href="a00096.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>=&quot;\n&quot;)</td></tr>
<tr class="memdesc:a79595103df6c363aba76db5ce49312ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a newly created subgroup to the group <br /></td></tr>
<tr class="separator:a79595103df6c363aba76db5ce49312ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f624e9a95eb0b58dff0ac2a10fb6ed9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f624e9a95eb0b58dff0ac2a10fb6ed9"></a>
base_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#a5f624e9a95eb0b58dff0ac2a10fb6ed9">add_decorator</a> (const std::string &amp;label, const std::string &amp;decorator_type, const std::string &amp;options=&quot;&quot;, const std::string &amp;<a class="el" href="a00096.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>=&quot;\n&quot;)</td></tr>
<tr class="memdesc:a5f624e9a95eb0b58dff0ac2a10fb6ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a newly created decorator to the group <br /></td></tr>
<tr class="separator:a5f624e9a95eb0b58dff0ac2a10fb6ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4c2c18d5da07d5dadfececde56e48e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec4c2c18d5da07d5dadfececde56e48e"></a>
<a class="el" href="a00710.html#aa04f44687debf1768006e544f64815b8">button_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#aec4c2c18d5da07d5dadfececde56e48e">add_button</a> (const std::string &amp;label, const std::string &amp;options=&quot;&quot;, const std::string &amp;<a class="el" href="a00096.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>=&quot;\n&quot;)</td></tr>
<tr class="memdesc:aec4c2c18d5da07d5dadfececde56e48e"><td class="mdescLeft">&#160;</td><td class="mdescRight">use the current gui driver to append a new button with the given label <br /></td></tr>
<tr class="separator:aec4c2c18d5da07d5dadfececde56e48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131206860106d3d07078508006151b7e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a131206860106d3d07078508006151b7e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a131206860106d3d07078508006151b7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00075.html">data::ref_ptr</a>&lt; <a class="el" href="a00102.html">view</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00096.html#a131206860106d3d07078508006151b7e">add_view</a> (const std::string &amp;label, const T &amp;value, const std::string &amp;gui_type=&quot;&quot;, const std::string &amp;options=&quot;&quot;, const std::string &amp;<a class="el" href="a00096.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>=&quot;\n&quot;)</td></tr>
<tr class="memdesc:a131206860106d3d07078508006151b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">use this to add a new view to the gui with a given value type, gui type and init options <br /></td></tr>
<tr class="separator:a131206860106d3d07078508006151b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5d812a9dc6b4132b67d0077cc6e22f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ace5d812a9dc6b4132b67d0077cc6e22f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace5d812a9dc6b4132b67d0077cc6e22f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00075.html">data::ref_ptr</a>&lt; <a class="el" href="a00084.html">control</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00096.html#ace5d812a9dc6b4132b67d0077cc6e22f">add_control</a> (const std::string &amp;label, T &amp;value, const std::string &amp;gui_type=&quot;&quot;, const std::string &amp;options=&quot;&quot;, const std::string &amp;<a class="el" href="a00096.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>=&quot;\n&quot;)</td></tr>
<tr class="memdesc:ace5d812a9dc6b4132b67d0077cc6e22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">use this to add a new control to the gui with a given value type, gui type and init options <br /></td></tr>
<tr class="separator:ace5d812a9dc6b4132b67d0077cc6e22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accde83e8bacb794c0c912334c5a743e4"><td class="memTemplParams" colspan="2"><a class="anchor" id="accde83e8bacb794c0c912334c5a743e4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:accde83e8bacb794c0c912334c5a743e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00075.html">data::ref_ptr</a>&lt; <a class="el" href="a00084.html">control</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00096.html#accde83e8bacb794c0c912334c5a743e4">add_control</a> (const std::string &amp;label, <a class="el" href="a00085.html">control_provider</a>&lt; T &gt; *<a class="el" href="a00096.html">provider</a>, const std::string &amp;gui_type=&quot;&quot;, const std::string &amp;options=&quot;&quot;, const std::string &amp;<a class="el" href="a00096.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>=&quot;\n&quot;, void *user_data=0)</td></tr>
<tr class="memdesc:accde83e8bacb794c0c912334c5a743e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">use this to add a new control to the gui, where the control is implemented with a control provider class <br /></td></tr>
<tr class="separator:accde83e8bacb794c0c912334c5a743e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52605f8fcf3865a48a942ffa3552ca30"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a52605f8fcf3865a48a942ffa3552ca30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00096.html#a52605f8fcf3865a48a942ffa3552ca30">add_member_control</a> (<a class="el" href="a00019.html">cgv::base::base</a> *base_ptr, const std::string &amp;label, T &amp;value, const std::string &amp;gui_type=&quot;&quot;, const std::string &amp;options=&quot;&quot;, const std::string &amp;<a class="el" href="a00096.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>=&quot;\n&quot;)</td></tr>
<tr class="memdesc:a52605f8fcf3865a48a942ffa3552ca30"><td class="mdescLeft">&#160;</td><td class="mdescRight">add control with callback to cgv::base::on_set method on <a class="el" href="a00084.html#a49af8e128fc1e8443b95adbddfed009a" title="this signal is sent after the user triggered a change of value and the check_value succeeded...">cgv::gui::control::value_change</a>  <a href="#a52605f8fcf3865a48a942ffa3552ca30">More...</a><br /></td></tr>
<tr class="separator:a52605f8fcf3865a48a942ffa3552ca30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d52460406852908aeaceb573cbd00e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#a71d52460406852908aeaceb573cbd00e">add_tree_node</a> (const std::string &amp;label, bool &amp;toggle, int level, const std::string &amp;a=&quot;\n&quot;, gui_group_ptr ggp=<a class="el" href="a00710.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>())</td></tr>
<tr class="memdesc:a71d52460406852908aeaceb573cbd00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a collapsable node to the gui (deprecated)  <a href="#a71d52460406852908aeaceb573cbd00e">More...</a><br /></td></tr>
<tr class="separator:a71d52460406852908aeaceb573cbd00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ba041ea08c3e6e3a93e76995f706aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a62ba041ea08c3e6e3a93e76995f706aa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00096.html#a62ba041ea08c3e6e3a93e76995f706aa">begin_tree_node</a> (const std::string &amp;label, const T &amp;value, bool initial_visibility=false, const std::string &amp;options=&quot;&quot;, <a class="el" href="a00710.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a> ggp=<a class="el" href="a00710.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>())</td></tr>
<tr class="memdesc:a62ba041ea08c3e6e3a93e76995f706aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin a sub tree of a tree structured gui.  <a href="#a62ba041ea08c3e6e3a93e76995f706aa">More...</a><br /></td></tr>
<tr class="separator:a62ba041ea08c3e6e3a93e76995f706aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bac0aa7c0467b606a3cbe9311f3d17c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9bac0aa7c0467b606a3cbe9311f3d17c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00096.html#a9bac0aa7c0467b606a3cbe9311f3d17c">end_tree_node</a> (const T &amp;value)</td></tr>
<tr class="separator:a9bac0aa7c0467b606a3cbe9311f3d17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1952a33f74f7e92a7e748548328cfea3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1952a33f74f7e92a7e748548328cfea3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1952a33f74f7e92a7e748548328cfea3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00096.html#a1952a33f74f7e92a7e748548328cfea3">is_tree_node_visible</a> (const T &amp;value) const </td></tr>
<tr class="memdesc:a1952a33f74f7e92a7e748548328cfea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether the sub tree attached to a value is visible <br /></td></tr>
<tr class="separator:a1952a33f74f7e92a7e748548328cfea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb70e048faeac605a62847f681c201b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3bb70e048faeac605a62847f681c201b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3bb70e048faeac605a62847f681c201b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00096.html#a3bb70e048faeac605a62847f681c201b">set_tree_node_visibility</a> (const T &amp;value, bool is_visible)</td></tr>
<tr class="memdesc:a3bb70e048faeac605a62847f681c201b"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the visibility status of sub tree attached to a value. This calls the post_recreate method if needed. <br /></td></tr>
<tr class="separator:a3bb70e048faeac605a62847f681c201b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a782d2dc8ba7aab891b7139bc8f5be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21a782d2dc8ba7aab891b7139bc8f5be"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#a21a782d2dc8ba7aab891b7139bc8f5be">begin_tree_node_void</a> (const std::string &amp;label, const void *value_ptr, int index=-1, bool initial_visibility=false, const std::string &amp;options=&quot;&quot;, <a class="el" href="a00710.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a> ggp=<a class="el" href="a00710.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>())</td></tr>
<tr class="memdesc:a21a782d2dc8ba7aab891b7139bc8f5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">void version of the templated functions <br /></td></tr>
<tr class="separator:a21a782d2dc8ba7aab891b7139bc8f5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8490e597634729bb37cb370483de7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b8490e597634729bb37cb370483de7d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>end_tree_node_void</b> (const void *value_ptr, int index=-1)</td></tr>
<tr class="separator:a7b8490e597634729bb37cb370483de7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf0e563fe5848e380f5b07e7582f7c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cf0e563fe5848e380f5b07e7582f7c2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_tree_node_visible_void</b> (const void *value_ptr, int index) const </td></tr>
<tr class="separator:a7cf0e563fe5848e380f5b07e7582f7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f634cc86cdcb2a65aa1921bd461a1fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f634cc86cdcb2a65aa1921bd461a1fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_tree_node_visibility_void</b> (const void *value_ptr, int index, bool is_visible)</td></tr>
<tr class="separator:a8f634cc86cdcb2a65aa1921bd461a1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05025e09df1d16f40678661b83c79bc8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a05025e09df1d16f40678661b83c79bc8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00096.html#a05025e09df1d16f40678661b83c79bc8">add_gui</a> (const std::string &amp;label, T &amp;value, const std::string &amp;gui_type=&quot;&quot;, const std::string &amp;options=&quot;&quot;)</td></tr>
<tr class="memdesc:a05025e09df1d16f40678661b83c79bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a composed gui of the given gui_type for the given value.  <a href="#a05025e09df1d16f40678661b83c79bc8">More...</a><br /></td></tr>
<tr class="separator:a05025e09df1d16f40678661b83c79bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">update of gui</div></td></tr>
<tr class="memitem:aeebc6429f63628979eaf49422f43af28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeebc6429f63628979eaf49422f43af28"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#aeebc6429f63628979eaf49422f43af28">remove_element</a> (base_ptr)</td></tr>
<tr class="memdesc:aeebc6429f63628979eaf49422f43af28"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove a single element from the gui <br /></td></tr>
<tr class="separator:aeebc6429f63628979eaf49422f43af28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e328fb6f5cf42f38194d0be355f4db1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e328fb6f5cf42f38194d0be355f4db1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#a0e328fb6f5cf42f38194d0be355f4db1">remove_all_elements</a> ()</td></tr>
<tr class="memdesc:a0e328fb6f5cf42f38194d0be355f4db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">this method removes all elements from the gui and can be used in a method that rebuilds the complete gui <br /></td></tr>
<tr class="separator:a0e328fb6f5cf42f38194d0be355f4db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17089a0c7f9fa7f69088eef86fa7e15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae17089a0c7f9fa7f69088eef86fa7e15"></a>
base_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#ae17089a0c7f9fa7f69088eef86fa7e15">find_element</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ae17089a0c7f9fa7f69088eef86fa7e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">find a gui element by name in the current group, return empty pointer if not found <br /></td></tr>
<tr class="separator:ae17089a0c7f9fa7f69088eef86fa7e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4350ea3d268a289aff9a9b792d8eb7f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af4350ea3d268a289aff9a9b792d8eb7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00075.html">data::ref_ptr</a>&lt; <a class="el" href="a00102.html">view</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00096.html#af4350ea3d268a289aff9a9b792d8eb7f">find_view</a> (const T &amp;value, int *idx_ptr=0)</td></tr>
<tr class="memdesc:af4350ea3d268a289aff9a9b792d8eb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">find a view of a given class member  <a href="#af4350ea3d268a289aff9a9b792d8eb7f">More...</a><br /></td></tr>
<tr class="separator:af4350ea3d268a289aff9a9b792d8eb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e752ce7a60f2e4e978a54125fa036e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac9e752ce7a60f2e4e978a54125fa036e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00075.html">data::ref_ptr</a>&lt; <a class="el" href="a00084.html">control</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00096.html#ac9e752ce7a60f2e4e978a54125fa036e">find_control</a> (T &amp;value, int *idx_ptr=0)</td></tr>
<tr class="memdesc:ac9e752ce7a60f2e4e978a54125fa036e"><td class="mdescLeft">&#160;</td><td class="mdescRight">find a control of a given class member  <a href="#ac9e752ce7a60f2e4e978a54125fa036e">More...</a><br /></td></tr>
<tr class="separator:ac9e752ce7a60f2e4e978a54125fa036e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdacc36103adb320449d81fe939feabb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afdacc36103adb320449d81fe939feabb"></a>
<a class="el" href="a00710.html#aebf3fd94311cb8a2bcffb4634f1e73b1">control_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#afdacc36103adb320449d81fe939feabb">find_control_void</a> (void *value_ptr, int *idx_ptr)</td></tr>
<tr class="memdesc:afdacc36103adb320449d81fe939feabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">access to control of untyped member pointer <br /></td></tr>
<tr class="separator:afdacc36103adb320449d81fe939feabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a0e7b3023b00762456b7b8c5480328"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37a0e7b3023b00762456b7b8c5480328"></a>
<a class="el" href="a00710.html#aceb07fba6859effc2353f70788dd7f9b">view_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#a37a0e7b3023b00762456b7b8c5480328">find_view_void</a> (void *value_ptr, int *idx_ptr)</td></tr>
<tr class="memdesc:a37a0e7b3023b00762456b7b8c5480328"><td class="mdescLeft">&#160;</td><td class="mdescRight">access to view of untyped member pointer <br /></td></tr>
<tr class="separator:a37a0e7b3023b00762456b7b8c5480328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_a00249"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_a00249')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="a00249.html">cgv::signal::tacker</a></td></tr>
<tr class="memitem:a6135b6fe6a28da06bb816ec799c69148 inherit pub_methods_a00249"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6135b6fe6a28da06bb816ec799c69148"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00249.html#a6135b6fe6a28da06bb816ec799c69148">tacker</a> ()</td></tr>
<tr class="memdesc:a6135b6fe6a28da06bb816ec799c69148 inherit pub_methods_a00249"><td class="mdescLeft">&#160;</td><td class="mdescRight">implement to allow reimplementation of copy constructor <br /></td></tr>
<tr class="separator:a6135b6fe6a28da06bb816ec799c69148 inherit pub_methods_a00249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b98b0ce42743baf089c75a6a497389 inherit pub_methods_a00249"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00249.html#a03b98b0ce42743baf089c75a6a497389">tacker</a> (const <a class="el" href="a00249.html">tacker</a> &amp;)</td></tr>
<tr class="memdesc:a03b98b0ce42743baf089c75a6a497389 inherit pub_methods_a00249"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload to avoid copying of signals  <a href="#a03b98b0ce42743baf089c75a6a497389">More...</a><br /></td></tr>
<tr class="separator:a03b98b0ce42743baf089c75a6a497389 inherit pub_methods_a00249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ec68aa024a20b240e0fe3121de2f80 inherit pub_methods_a00249"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7ec68aa024a20b240e0fe3121de2f80"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00249.html#ad7ec68aa024a20b240e0fe3121de2f80">tack</a> (<a class="el" href="a00248.html">signal_base</a> *s) const </td></tr>
<tr class="memdesc:ad7ec68aa024a20b240e0fe3121de2f80 inherit pub_methods_a00249"><td class="mdescLeft">&#160;</td><td class="mdescRight">keep track of the given signal <br /></td></tr>
<tr class="separator:ad7ec68aa024a20b240e0fe3121de2f80 inherit pub_methods_a00249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d9601c0eb859044adebb5ddbd20112 inherit pub_methods_a00249"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13d9601c0eb859044adebb5ddbd20112"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00249.html#a13d9601c0eb859044adebb5ddbd20112">untack</a> (<a class="el" href="a00248.html">signal_base</a> *s) const </td></tr>
<tr class="memdesc:a13d9601c0eb859044adebb5ddbd20112 inherit pub_methods_a00249"><td class="mdescLeft">&#160;</td><td class="mdescRight">forget the given signal <br /></td></tr>
<tr class="separator:a13d9601c0eb859044adebb5ddbd20112 inherit pub_methods_a00249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696c1aefe18ddab1706509577aef5b35 inherit pub_methods_a00249"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a696c1aefe18ddab1706509577aef5b35"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00249.html#a696c1aefe18ddab1706509577aef5b35">untack_all</a> () const </td></tr>
<tr class="memdesc:a696c1aefe18ddab1706509577aef5b35 inherit pub_methods_a00249"><td class="mdescLeft">&#160;</td><td class="mdescRight">forget all signals <br /></td></tr>
<tr class="separator:a696c1aefe18ddab1706509577aef5b35 inherit pub_methods_a00249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7ccb1b1b1b07594bc277dfa21891fd inherit pub_methods_a00249"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a7ccb1b1b1b07594bc277dfa21891fd"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00249.html#a9a7ccb1b1b1b07594bc277dfa21891fd">~tacker</a> ()</td></tr>
<tr class="memdesc:a9a7ccb1b1b1b07594bc277dfa21891fd inherit pub_methods_a00249"><td class="mdescLeft">&#160;</td><td class="mdescRight">disconnect from all tacked signals on destruction <br /></td></tr>
<tr class="separator:a9a7ccb1b1b1b07594bc277dfa21891fd inherit pub_methods_a00249"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">callbacks</div></td></tr>
<tr class="memitem:ac21e975a89b32dcbbe9bdb39b4f452ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac21e975a89b32dcbbe9bdb39b4f452ca"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#ac21e975a89b32dcbbe9bdb39b4f452ca">on_select</a> ()</td></tr>
<tr class="memdesc:ac21e975a89b32dcbbe9bdb39b4f452ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">called by selection_change_cb whenever the gui of this provider is selected <br /></td></tr>
<tr class="separator:ac21e975a89b32dcbbe9bdb39b4f452ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d49da0a9a5f434b920c33d42139621"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6d49da0a9a5f434b920c33d42139621"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#ac6d49da0a9a5f434b920c33d42139621">on_deselect</a> ()</td></tr>
<tr class="memdesc:ac6d49da0a9a5f434b920c33d42139621"><td class="mdescLeft">&#160;</td><td class="mdescRight">called by selection_change_cb whenever the gui of this provider is deselected <br /></td></tr>
<tr class="separator:ac6d49da0a9a5f434b920c33d42139621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30ecc2b9412b158cbe774babaacd402"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af30ecc2b9412b158cbe774babaacd402"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#af30ecc2b9412b158cbe774babaacd402">selection_change_cb</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">cgv::base::base_ptr</a> new_child, bool selected)</td></tr>
<tr class="memdesc:af30ecc2b9412b158cbe774babaacd402"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is called by the gui group when the selection changes <br /></td></tr>
<tr class="separator:af30ecc2b9412b158cbe774babaacd402"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
interface used by the parent gui</h2></td></tr>
<tr class="memitem:afffb2e23a58a488448a175e6275c9e7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afffb2e23a58a488448a175e6275c9e7b"></a>
<a class="el" href="a00710.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#afffb2e23a58a488448a175e6275c9e7b">parent_group</a></td></tr>
<tr class="memdesc:afffb2e23a58a488448a175e6275c9e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">driver specific handle for the group gui element managing the gui built in the provider <br /></td></tr>
<tr class="separator:afffb2e23a58a488448a175e6275c9e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51c3efb4addaae6f9ab79e6f5d2f641"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab51c3efb4addaae6f9ab79e6f5d2f641"></a>
<a class="el" href="a00096.html">provider</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>parent_provider</b></td></tr>
<tr class="separator:ab51c3efb4addaae6f9ab79e6f5d2f641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac301065501736a49cc5ac35b06c05e0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac301065501736a49cc5ac35b06c05e0f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#ac301065501736a49cc5ac35b06c05e0f">gui_group</a></td></tr>
<tr class="memdesc:ac301065501736a49cc5ac35b06c05e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">make the gui group a friend class <br /></td></tr>
<tr class="separator:ac301065501736a49cc5ac35b06c05e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f6cb9fa8994a14fdb5bf70cba90093"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6f6cb9fa8994a14fdb5bf70cba90093"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#aa6f6cb9fa8994a14fdb5bf70cba90093">set_parent</a> (<a class="el" href="a00710.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>)</td></tr>
<tr class="memdesc:aa6f6cb9fa8994a14fdb5bf70cba90093"><td class="mdescLeft">&#160;</td><td class="mdescRight">the gui window sets the parent group through this method <br /></td></tr>
<tr class="separator:aa6f6cb9fa8994a14fdb5bf70cba90093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845b81cb3d12858b7b70a2b00105c72f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a845b81cb3d12858b7b70a2b00105c72f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html#a845b81cb3d12858b7b70a2b00105c72f">update_parent</a> ()</td></tr>
<tr class="memdesc:a845b81cb3d12858b7b70a2b00105c72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">update the parent group <br /></td></tr>
<tr class="separator:a845b81cb3d12858b7b70a2b00105c72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>derive from this class to provide a gui to the current viewer </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a05025e09df1d16f40678661b83c79bc8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::gui::provider::add_gui </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>gui_type</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a composed gui of the given gui_type for the given value. </p>
<p>This function returns false if no cgv::base::gui_creator has been registered for the given gui_type. The plugin cg_ext contains registers gui_creators for the most important types of the framework. The supported values for the options parameter are specific for the gui_type. Currently these are not documented and can only be found in the source code of the cg_ext plugin. </p>

</div>
</div>
<a class="anchor" id="a52605f8fcf3865a48a942ffa3552ca30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgv::gui::provider::add_member_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00019.html">cgv::base::base</a> *&#160;</td>
          <td class="paramname"><em>base_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>gui_type</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>align</em> = <code>&quot;\n&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add control with callback to cgv::base::on_set method on <a class="el" href="a00084.html#a49af8e128fc1e8443b95adbddfed009a" title="this signal is sent after the user triggered a change of value and the check_value succeeded...">cgv::gui::control::value_change</a> </p>
<p>use this method to add a control of a member and a callback to the on_set method of the <a class="el" href="a00019.html">cgv::base::base</a> class. </p>

</div>
</div>
<a class="anchor" id="a4f82aa4b9a568ca39bff1c1fa2fc637a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00710.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a> cgv::gui::provider::add_object_gui </td>
          <td>(</td>
          <td class="paramtype">base_ptr&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add a new group to the given parent group, not supported yet </p>
<p>Add group with the gui of another object inside.</p>
<p>Add a new group, where the group elements are defined by another object that must be derived from provider. You can use the same group types as in the add_group method. </p>

</div>
</div>
<a class="anchor" id="a71d52460406852908aeaceb573cbd00e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::gui::provider::add_tree_node </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>toggle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code>&quot;\n&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00710.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>&#160;</td>
          <td class="paramname"><em>ggp</em> = <code><a class="el" href="a00710.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add a collapsable node to the gui (deprecated) </p>
<p>This method is one possibility to support tree like guis with nodes that can be opened or closed. The other prefarable possibitly builds on the functions <a class="el" href="a00096.html#a62ba041ea08c3e6e3a93e76995f706aa" title="Begin a sub tree of a tree structured gui. ">begin_tree_node()</a> and <a class="el" href="a00096.html#a9bac0aa7c0467b606a3cbe9311f3d17c">end_tree_node()</a>. </p><pre class="fragment">Each node is represented by a heading with the text provided in the first parameter and of heading 
level specified in the first parameter. The state of the node is stored in a boolean variable
"toggle" that must be supplied by the implementation of the provider. The toggle needs to be
initialized in the constructor and is used in the create_gui method to only provide the gui of
the subtree if toggle is true. Every time the status of the node is changed, the whole gui is
rebuild with the post_recreate_gui method. The value of the toggle is also the return parameter 
of add_tree_node such the typical code inside the create_gui method looks
like
</pre> <div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="a00096.html#a71d52460406852908aeaceb573cbd00e">add_tree_node</a>(<span class="stringliteral">&quot;Node&quot;</span>, toggle, 2)) {</div>
<div class="line">   <a class="code" href="a00096.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>(<span class="stringliteral">&quot;\a&quot;</span>); <span class="comment">// indent gui elements of tree node</span></div>
<div class="line">   <span class="comment">// create gui of subtree</span></div>
<div class="line">   </div>
<div class="line">   <a class="code" href="a00096.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>(<span class="stringliteral">&quot;\b&quot;</span>); <span class="comment">// undo indentation</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a62ba041ea08c3e6e3a93e76995f706aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::gui::provider::begin_tree_node </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initial_visibility</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00710.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>&#160;</td>
          <td class="paramname"><em>ggp</em> = <code><a class="el" href="a00710.html#a24b531058de9d4333ab8541c302587d7">gui_group_ptr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin a sub tree of a tree structured gui. </p>
<p>This function addes a toggle button and a heading for the tree node. The toggle button can be used to show or hide the subtree below the tree node. The heading shows simply the label parameter. The function returns the visibility state of the subtree below the tree node. Therefore its contents should only be specified if the function returns true. In that case one needs to terminate the gui elements added for the tree node with the end_tree_node function. A typical example would be </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="a00096.html#a62ba041ea08c3e6e3a93e76995f706aa">begin_tree_node</a>(<span class="stringliteral">&quot;Node&quot;</span>, composed_value)) {</div>
<div class="line">   <a class="code" href="a00096.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>(<span class="stringliteral">&quot;\a&quot;</span>); <span class="comment">// indent gui elements of tree node</span></div>
<div class="line">   <span class="comment">// create gui of composed_value</span></div>
<div class="line">   </div>
<div class="line">   <a class="code" href="a00096.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>(<span class="stringliteral">&quot;\b&quot;</span>); <span class="comment">// undo indentation</span></div>
<div class="line">   <a class="code" href="a00096.html#a9bac0aa7c0467b606a3cbe9311f3d17c">end_tree_node</a>(composed_value);</div>
<div class="line">}</div>
</div><!-- fragment --><p> The state of the toggle button is attached to a boolean variable that is globally managed by the provider. For this the reference to a value controlled by the tree node is specified. The pointer to the controlled value is used as key for a map that manages the toggle states of all tree node buttons. If there is no superior structure whose value is controlled by the tree node, one can specify any of the values controled by the tree node. It is just important that no two tree nodes use the same value and that the pointer to the value cannot change. The latter is for example the case, when one uses an entry in a std::vector that can change size and reallocate its values. Then one should use the std::vector itself as value. In order to be able to distinguish the different elements of a vector one can extend the key from a value reference to a pair of a value reference plus an index. The index is then the index of the vector element. This is done by specifying with_index(value, idx) in the value argument. An example could look as follows: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="a00096.html#a62ba041ea08c3e6e3a93e76995f706aa">begin_tree_node</a>(<span class="stringliteral">&quot;Node&quot;</span>, vec)) {</div>
<div class="line">   <a class="code" href="a00096.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>(<span class="stringliteral">&quot;\a&quot;</span>); <span class="comment">// indent gui elements of tree node</span></div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;vec.size; ++i) {</div>
<div class="line">                <span class="keywordflow">if</span> (<a class="code" href="a00096.html#a62ba041ea08c3e6e3a93e76995f706aa">begin_tree_node</a>(std::string(<span class="stringliteral">&quot;element &quot;</span>)+cgv::utils::to_string(i), <a class="code" href="a00710.html#aa887b469731f8956d0eaefd8801fc4a3">with_index</a>(vec,i))) {</div>
<div class="line">                   <a class="code" href="a00096.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>(<span class="stringliteral">&quot;\a&quot;</span>); <span class="comment">// indent gui elements of tree node for vector element</span></div>
<div class="line">                   <span class="comment">// create gui of vector element</span></div>
<div class="line">   </div>
<div class="line">                   <a class="code" href="a00096.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>(<span class="stringliteral">&quot;\b&quot;</span>); <span class="comment">// undo indentation</span></div>
<div class="line">                   <a class="code" href="a00096.html#a9bac0aa7c0467b606a3cbe9311f3d17c">end_tree_node</a>(<a class="code" href="a00710.html#aa887b469731f8956d0eaefd8801fc4a3">with_index</a>(vec,i));</div>
<div class="line">                }</div>
<div class="line">        }</div>
<div class="line">        <a class="code" href="a00096.html#a28af4e659bdd1825f3829263e15ce5ae">align</a>(<span class="stringliteral">&quot;\b&quot;</span>); <span class="comment">// undo indentation</span></div>
<div class="line">        <a class="code" href="a00096.html#a9bac0aa7c0467b606a3cbe9311f3d17c">end_tree_node</a>(vec);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a9bac0aa7c0467b606a3cbe9311f3d17c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgv::gui::provider::end_tree_node </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>template specialization that allows to specify value reference plus node_instance by using the result of the function with_instance(value,idx) for the value argument finish a sub tree begun with begin_tree_node</p>
<p>This functions should be called only if the corresponding call to begin_tree_node returned true. </p>

</div>
</div>
<a class="anchor" id="ac9e752ce7a60f2e4e978a54125fa036e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00075.html">data::ref_ptr</a>&lt;<a class="el" href="a00084.html">control</a>&lt;T&gt; &gt; cgv::gui::provider::find_control </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>idx_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find a control of a given class member </p>
<p>find the next control of the given value in the current group. If the index pointer is given, start at the index to which the pointer points and set this index to the index of the child index of the found control </p>

</div>
</div>
<a class="anchor" id="af4350ea3d268a289aff9a9b792d8eb7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00075.html">data::ref_ptr</a>&lt;<a class="el" href="a00102.html">view</a>&lt;T&gt; &gt; cgv::gui::provider::find_view </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>idx_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find a view of a given class member </p>
<p>find the next view of the given value in the current group. If the index pointer is given, start at the index to which the pointer points and set this index to the index of the child index of the found view </p>

</div>
</div>
<a class="anchor" id="a2ed7b09695efb1d3ea4072ab355e41fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string cgv::gui::provider::get_gui_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derive a name for this instance that can be used in the gui as heading. </p>
<p>This method uses the following strategy to automatically determine the name shown in guis for a provider instance:</p><ul>
<li>try to cast the object into <a class="el" href="a00039.html">cgv::base::named</a>, if successful, use get_name() method</li>
<li>check whether <a class="el" href="a00096.html#a39610a27c1eef83fd785e52ba11c726c" title="return a path in the main menu to select the gui ">get_menu_path()</a> results in a path or name. In case of a path, use the last entry of the path as name.</li>
<li>try to cast to <a class="el" href="a00019.html">cgv::base::base</a> and use get_type_name().</li>
<li>return "unnamed" otherwise</li>
</ul>
<p>this method uses the following strategy to automatically determine the name shown in guis for a provider instance:</p><ul>
<li>try to cast the object into <a class="el" href="a00039.html">cgv::base::named</a>, if successful, use get_name() method</li>
<li>check whether <a class="el" href="a00096.html#a39610a27c1eef83fd785e52ba11c726c" title="return a path in the main menu to select the gui ">get_menu_path()</a> results in a path or name. In case of a path, use the last entry of the path as name.</li>
<li>try to cast to <a class="el" href="a00019.html">cgv::base::base</a> and use get_type_name().</li>
<li>return "unnamed" otherwise </li>
</ul>

</div>
</div>
<a class="anchor" id="ad8c795cd30d68706c3aac1d2abc1f9d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string cgv::gui::provider::get_parent_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the group type that should be used by the class embedding the gui of the provider. </p>
<p>The default is to use a group of type "align_group". Overload this virtual method to use a different group type, such as layout group. </p>

</div>
</div>
<a class="anchor" id="aa91a5b7508ca2f8a995a7101a80cab76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgv::gui::provider::post_recreate_gui </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>delayed recreation of gui </p>
<p>schedule the recreation of the gui for the next time the program is idle. This mechanism is implemented in a thread save way. </p>

</div>
</div>
<a class="anchor" id="ab71df33b57067886a8c264ed9eb672f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgv::gui::provider::recreate_gui </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recreate the gui of this instance right now. </p>
<p>Use this method to recreate the gui, dont call create gui directly. Be careful when calling the method from a functor that is attached to a gui element generated by this provider. This can cause the gui element to be destroyed before the callback triggering the recreate_gui method has been completely finished, what might make the program crash. Use the post_recreate_gui method instead. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="a00590_source.html">provider.h</a></li>
<li>provider.cxx</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00704.html">cgv</a></li><li class="navelem"><a class="el" href="a00710.html">gui</a></li><li class="navelem"><a class="el" href="a00096.html">provider</a></li>
    <li class="footer">Generated on Mon Jun 26 2017 12:41:49 for cgv by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
