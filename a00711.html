<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>cgv: cgv::math Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cgv
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00711.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cgv::math Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>namespace with classes and algorithms for mathematics  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00105.html">adjacency_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html">diag_mat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00107.html">fibo_heap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html">fvec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html">interval</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html">mat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00111.html">mfunc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html">perm_mat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00113.html">qem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">dimension independent implementation of quadric error metrics  <a href="a00113.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00114.html">quaternion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html">random</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html">register_sparse_les_factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper template to register a sparse les solver  <a href="a00116.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html">rigid_transform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00118.html">sparse_les</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html">sparse_les_factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">factory class for sparse linear system solvers  <a href="a00119.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html">sparse_les_factory_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of factory class for sparse linear system solvers  <a href="a00120.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00121.html">thin_hyper_plate_spline</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00122.html">thin_plate_spline</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html">tri_diag_mat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00124.html">union_find</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00125.html">v2_func</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00126.html">v3_func</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html">vec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector class.  <a href="a00127.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1ee5ee26c821419a8c7c5efbf583d424"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ee5ee26c821419a8c7c5efbf583d424"></a>
typedef <a class="el" href="a00075.html">cgv::data::ref_ptr</a><br class="typebreak" />
&lt; <a class="el" href="a00118.html">sparse_les</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00711.html#a1ee5ee26c821419a8c7c5efbf583d424">sparse_les_ptr</a></td></tr>
<tr class="memdesc:a1ee5ee26c821419a8c7c5efbf583d424"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference counted pointer type for sparse les solver <br /></td></tr>
<tr class="separator:a1ee5ee26c821419a8c7c5efbf583d424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5cba5eba7be3c4228793a426cbb5944"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5cba5eba7be3c4228793a426cbb5944"></a>
typedef <a class="el" href="a00075.html">cgv::data::ref_ptr</a><br class="typebreak" />
&lt; <a class="el" href="a00119.html">sparse_les_factory</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00711.html#ab5cba5eba7be3c4228793a426cbb5944">sparse_les_factory_ptr</a></td></tr>
<tr class="memdesc:ab5cba5eba7be3c4228793a426cbb5944"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference counted pointer type for sparse les solver factories <br /></td></tr>
<tr class="separator:ab5cba5eba7be3c4228793a426cbb5944"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a22446204b5909c06423af9ce96233507"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22446204b5909c06423af9ce96233507"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00711.html#a22446204b5909c06423af9ce96233507">SparseLesCaps</a> </td></tr>
<tr class="memdesc:a22446204b5909c06423af9ce96233507"><td class="mdescLeft">&#160;</td><td class="mdescRight">capability options for a sparse linear solver <br /></td></tr>
<tr class="separator:a22446204b5909c06423af9ce96233507"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a334232cf858e03e53db9bbf416fc76e3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a334232cf858e03e53db9bbf416fc76e3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a334232cf858e03e53db9bbf416fc76e3">bipoly_val</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;bp, const T &amp;x1, const T &amp;x2)</td></tr>
<tr class="separator:a334232cf858e03e53db9bbf416fc76e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c3df147faeb70898d5d8be36ee6989"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a71c3df147faeb70898d5d8be36ee6989"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a71c3df147faeb70898d5d8be36ee6989">bipoly_val</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;bp, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a71c3df147faeb70898d5d8be36ee6989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd02962dd3e20c230b6920c4baa6b1cf"><td class="memTemplParams" colspan="2"><a class="anchor" id="abd02962dd3e20c230b6920c4baa6b1cf"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd02962dd3e20c230b6920c4baa6b1cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#abd02962dd3e20c230b6920c4baa6b1cf">bipoly_int_x1</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;bp, const T &amp;k=0)</td></tr>
<tr class="memdesc:abd02962dd3e20c230b6920c4baa6b1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">analytic integration of bivariate polynomial int p(x1,x2) dx1 <br /></td></tr>
<tr class="separator:abd02962dd3e20c230b6920c4baa6b1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d44c29d8541df107111af2d9b2e179"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae3d44c29d8541df107111af2d9b2e179"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae3d44c29d8541df107111af2d9b2e179"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ae3d44c29d8541df107111af2d9b2e179">bipoly_int_x2</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;bp, const T &amp;k=0)</td></tr>
<tr class="memdesc:ae3d44c29d8541df107111af2d9b2e179"><td class="mdescLeft">&#160;</td><td class="mdescRight">analytic integration of bivariate polynomial int p(x1,x2) dx2 <br /></td></tr>
<tr class="separator:ae3d44c29d8541df107111af2d9b2e179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b594665950a0417ea397d6d419fe826"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b594665950a0417ea397d6d419fe826"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a2b594665950a0417ea397d6d419fe826">create_color_map</a> (unsigned steps=256, std::string name=&quot;jet&quot;)</td></tr>
<tr class="separator:a2b594665950a0417ea397d6d419fe826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3795d992bc753f74302f173f646c2cfe"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3795d992bc753f74302f173f646c2cfe"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3795d992bc753f74302f173f646c2cfe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a3795d992bc753f74302f173f646c2cfe">rgb_2_xyz</a> (<a class="el" href="a00110.html">math::mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a3795d992bc753f74302f173f646c2cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert matrix columns from rgb to xyz <br /></td></tr>
<tr class="separator:a3795d992bc753f74302f173f646c2cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ebf9f24bcb148bc9e5afc87dac508e7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4ebf9f24bcb148bc9e5afc87dac508e7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4ebf9f24bcb148bc9e5afc87dac508e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">math::vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a4ebf9f24bcb148bc9e5afc87dac508e7">xyz_2_rgb</a> (const <a class="el" href="a00127.html">math::vec</a>&lt; T &gt; &amp;xyz)</td></tr>
<tr class="memdesc:a4ebf9f24bcb148bc9e5afc87dac508e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert colo vector from xyz to rgb <br /></td></tr>
<tr class="separator:a4ebf9f24bcb148bc9e5afc87dac508e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298492e84c1a1e16cf57c3130a5e250e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a298492e84c1a1e16cf57c3130a5e250e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a298492e84c1a1e16cf57c3130a5e250e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a298492e84c1a1e16cf57c3130a5e250e">xyz_2_rgb</a> (<a class="el" href="a00110.html">math::mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a298492e84c1a1e16cf57c3130a5e250e"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert matrix columns from xyz to rgb <br /></td></tr>
<tr class="separator:a298492e84c1a1e16cf57c3130a5e250e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4e6bd4309b6498f27ab4d9a6d9e8f8"><td class="memTemplParams" colspan="2"><a class="anchor" id="add4e6bd4309b6498f27ab4d9a6d9e8f8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:add4e6bd4309b6498f27ab4d9a6d9e8f8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00106.html">diag_mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#add4e6bd4309b6498f27ab4d9a6d9e8f8">operator*</a> (const T &amp;s, const <a class="el" href="a00106.html">diag_mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:add4e6bd4309b6498f27ab4d9a6d9e8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplication of scalar s and diagonal matrix m <br /></td></tr>
<tr class="separator:add4e6bd4309b6498f27ab4d9a6d9e8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73290cc8b3dc6aef55ceb9067d450db7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a73290cc8b3dc6aef55ceb9067d450db7"></a>
template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a73290cc8b3dc6aef55ceb9067d450db7"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00106.html">diag_mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a73290cc8b3dc6aef55ceb9067d450db7">operator*</a> (const <a class="el" href="a00106.html">diag_mat</a>&lt; S &gt; &amp;s, const <a class="el" href="a00106.html">diag_mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a73290cc8b3dc6aef55ceb9067d450db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix multiplication of diagonal matrix s and m <br /></td></tr>
<tr class="separator:a73290cc8b3dc6aef55ceb9067d450db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c3be3cf3933d0707bbce702589b296"><td class="memTemplParams" colspan="2"><a class="anchor" id="a65c3be3cf3933d0707bbce702589b296"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a65c3be3cf3933d0707bbce702589b296"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a65c3be3cf3933d0707bbce702589b296">operator*</a> (const <a class="el" href="a00112.html">perm_mat</a> &amp;p, const <a class="el" href="a00106.html">diag_mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a65c3be3cf3933d0707bbce702589b296"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplies a permutation matrix from left to apply a rows permutation <br /></td></tr>
<tr class="separator:a65c3be3cf3933d0707bbce702589b296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b33039575323f0ab6d45f75525895ad"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3b33039575323f0ab6d45f75525895ad"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b33039575323f0ab6d45f75525895ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a3b33039575323f0ab6d45f75525895ad">operator*</a> (const <a class="el" href="a00106.html">diag_mat</a>&lt; T &gt; &amp;m, const <a class="el" href="a00112.html">perm_mat</a> &amp;p)</td></tr>
<tr class="memdesc:a3b33039575323f0ab6d45f75525895ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplies a permutation matrix from right to apply a rows permutation <br /></td></tr>
<tr class="separator:a3b33039575323f0ab6d45f75525895ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1ac596b696fed9bf9de9f94da38aac"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3c1ac596b696fed9bf9de9f94da38aac"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3c1ac596b696fed9bf9de9f94da38aac"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a3c1ac596b696fed9bf9de9f94da38aac">operator*</a> (const <a class="el" href="a00106.html">diag_mat</a>&lt; T &gt; &amp;s, const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a3c1ac596b696fed9bf9de9f94da38aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix multiplication of matrix m by a diagonal matrix s <br /></td></tr>
<tr class="separator:a3c1ac596b696fed9bf9de9f94da38aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3184ae8911e141826cfb582cffe2fc98"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3184ae8911e141826cfb582cffe2fc98"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3184ae8911e141826cfb582cffe2fc98"><td class="memTemplItemLeft" align="right" valign="top">const up_tri_mat&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a3184ae8911e141826cfb582cffe2fc98">operator*</a> (const up_tri_mat&lt; T &gt; &amp;m, const <a class="el" href="a00106.html">diag_mat</a>&lt; T &gt; &amp;s)</td></tr>
<tr class="memdesc:a3184ae8911e141826cfb582cffe2fc98"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix multiplication of upper triangular matrix m by a diagonal matrix s <br /></td></tr>
<tr class="separator:a3184ae8911e141826cfb582cffe2fc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959d852b32d156d183107537cc965ca7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a959d852b32d156d183107537cc965ca7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a959d852b32d156d183107537cc965ca7"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a959d852b32d156d183107537cc965ca7">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="a00106.html">diag_mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a959d852b32d156d183107537cc965ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">output of a diagonal matrix onto an ostream <br /></td></tr>
<tr class="separator:a959d852b32d156d183107537cc965ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bdff18efd6afb8e7d19406cb7664e51"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4bdff18efd6afb8e7d19406cb7664e51"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4bdff18efd6afb8e7d19406cb7664e51"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a4bdff18efd6afb8e7d19406cb7664e51">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="a00106.html">diag_mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a4bdff18efd6afb8e7d19406cb7664e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">input of a diagonal matrix from an istream <br /></td></tr>
<tr class="separator:a4bdff18efd6afb8e7d19406cb7664e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a12451076df1957fe4247589887704d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1a12451076df1957fe4247589887704d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a1a12451076df1957fe4247589887704d">sqrdist_transf_1d</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;f, <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;d)</td></tr>
<tr class="separator:a1a12451076df1957fe4247589887704d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae111715a4f488edeb34ecbd1d790ece3"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae111715a4f488edeb34ecbd1d790ece3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae111715a4f488edeb34ecbd1d790ece3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ae111715a4f488edeb34ecbd1d790ece3">sqrdist_transf_2d</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;input, <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;output, T on=1)</td></tr>
<tr class="memdesc:ae111715a4f488edeb34ecbd1d790ece3"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the squared distance transform of an input image <br /></td></tr>
<tr class="separator:ae111715a4f488edeb34ecbd1d790ece3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb7ef1ba387bc69a8ee0eedd008b140"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6fb7ef1ba387bc69a8ee0eedd008b140"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6fb7ef1ba387bc69a8ee0eedd008b140"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a6fb7ef1ba387bc69a8ee0eedd008b140">dist_transf_2d</a> (<a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;input, <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;output, T on=1)</td></tr>
<tr class="memdesc:a6fb7ef1ba387bc69a8ee0eedd008b140"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the distance transform of an input image <br /></td></tr>
<tr class="separator:a6fb7ef1ba387bc69a8ee0eedd008b140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edcbce1ad75f9e7f698dfe11e8f41f4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7edcbce1ad75f9e7f698dfe11e8f41f4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a7edcbce1ad75f9e7f698dfe11e8f41f4">eig_sym</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;a, <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;v, <a class="el" href="a00106.html">diag_mat</a>&lt; T &gt; &amp;d, bool ordering=true, unsigned maxiter=50)</td></tr>
<tr class="separator:a7edcbce1ad75f9e7f698dfe11e8f41f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f639abf33334ad93ab52dbdaa19abf"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae1f639abf33334ad93ab52dbdaa19abf"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:ae1f639abf33334ad93ab52dbdaa19abf"><td class="memTemplItemLeft" align="right" valign="top">fmat&lt; T, N, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ae1f639abf33334ad93ab52dbdaa19abf">transpose</a> (const fmat&lt; T, N, N &gt; &amp;m)</td></tr>
<tr class="memdesc:ae1f639abf33334ad93ab52dbdaa19abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the transposed of a square matrix <br /></td></tr>
<tr class="separator:ae1f639abf33334ad93ab52dbdaa19abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e21658387fcb926d7d2107455b93e6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a98e21658387fcb926d7d2107455b93e6"></a>
template&lt;typename T , cgv::type::uint32_type N, cgv::type::uint32_type M&gt; </td></tr>
<tr class="memitem:a98e21658387fcb926d7d2107455b93e6"><td class="memTemplItemLeft" align="right" valign="top">fmat&lt; T, N, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a98e21658387fcb926d7d2107455b93e6">operator*</a> (const T &amp;s, const fmat&lt; T, N, M &gt; &amp;m)</td></tr>
<tr class="memdesc:a98e21658387fcb926d7d2107455b93e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the product of a scalar s and a matrix m <br /></td></tr>
<tr class="separator:a98e21658387fcb926d7d2107455b93e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6566df1a94d71d55d3335f25ab53153d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6566df1a94d71d55d3335f25ab53153d"></a>
template&lt;typename T , cgv::type::uint32_type N, cgv::type::uint32_type M&gt; </td></tr>
<tr class="memitem:a6566df1a94d71d55d3335f25ab53153d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00108.html">fvec</a>&lt; T, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a6566df1a94d71d55d3335f25ab53153d">operator*</a> (const <a class="el" href="a00108.html">fvec</a>&lt; T, N &gt; &amp;v_row, const fmat&lt; T, N, M &gt; &amp;m)</td></tr>
<tr class="memdesc:a6566df1a94d71d55d3335f25ab53153d"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiply a row vector from the left to matrix m and return a row vector <br /></td></tr>
<tr class="separator:a6566df1a94d71d55d3335f25ab53153d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5761c72337c6456a9e5830a88e845c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3e5761c72337c6456a9e5830a88e845c"></a>
template&lt;typename T , cgv::type::uint32_type N, cgv::type::uint32_type M&gt; </td></tr>
<tr class="memitem:a3e5761c72337c6456a9e5830a88e845c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a3e5761c72337c6456a9e5830a88e845c">operator&lt;&lt;</a> (std::ostream &amp;out, const fmat&lt; T, N, M &gt; &amp;m)</td></tr>
<tr class="memdesc:a3e5761c72337c6456a9e5830a88e845c"><td class="mdescLeft">&#160;</td><td class="mdescRight">output of a matrix onto an ostream <br /></td></tr>
<tr class="separator:a3e5761c72337c6456a9e5830a88e845c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42e4ccbb7f1f909ddebc4ca3a15d70a"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa42e4ccbb7f1f909ddebc4ca3a15d70a"></a>
template&lt;typename T , cgv::type::uint32_type N, cgv::type::uint32_type M&gt; </td></tr>
<tr class="memitem:aa42e4ccbb7f1f909ddebc4ca3a15d70a"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#aa42e4ccbb7f1f909ddebc4ca3a15d70a">operator&gt;&gt;</a> (std::istream &amp;in, fmat&lt; T, N, M &gt; &amp;m)</td></tr>
<tr class="memdesc:aa42e4ccbb7f1f909ddebc4ca3a15d70a"><td class="mdescLeft">&#160;</td><td class="mdescRight">input of a matrix onto an ostream <br /></td></tr>
<tr class="separator:aa42e4ccbb7f1f909ddebc4ca3a15d70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6834066b8a9e1319b63e48423c67baa5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6834066b8a9e1319b63e48423c67baa5"></a>
template&lt;typename T , cgv::type::uint32_type N, typename S , cgv::type::uint32_type M&gt; </td></tr>
<tr class="memitem:a6834066b8a9e1319b63e48423c67baa5"><td class="memTemplItemLeft" align="right" valign="top">fmat&lt; T, N, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a6834066b8a9e1319b63e48423c67baa5">dyad</a> (const <a class="el" href="a00108.html">fvec</a>&lt; T, N &gt; &amp;v, const <a class="el" href="a00108.html">fvec</a>&lt; S, M &gt; &amp;w)</td></tr>
<tr class="memdesc:a6834066b8a9e1319b63e48423c67baa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the outer product of vector v and w <br /></td></tr>
<tr class="separator:a6834066b8a9e1319b63e48423c67baa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4a644a254ea830977b0d01fe93d91f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a4a644a254ea830977b0d01fe93d91f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00711.html#a2a4a644a254ea830977b0d01fe93d91f">compute_unit_ball_volume</a> (unsigned n)</td></tr>
<tr class="memdesc:a2a4a644a254ea830977b0d01fe93d91f"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute volume of unit n-ball living in n-dimensional space with n&gt;=1; results are cached for O(1) runtime <br /></td></tr>
<tr class="separator:a2a4a644a254ea830977b0d01fe93d91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf9b277cd0690655f553db567b1c053"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1cf9b277cd0690655f553db567b1c053"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00711.html#a1cf9b277cd0690655f553db567b1c053">compute_ball_volume</a> (unsigned n, double R)</td></tr>
<tr class="memdesc:a1cf9b277cd0690655f553db567b1c053"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute volume of n-ball of radius R living in n-dimensional space with n&gt;=1; results are cached for O(1) runtime <br /></td></tr>
<tr class="separator:a1cf9b277cd0690655f553db567b1c053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d907d9219c652396ff81057de4bae6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3d907d9219c652396ff81057de4bae6"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00711.html#ad3d907d9219c652396ff81057de4bae6">compute_unit_sphere_area</a> (unsigned n)</td></tr>
<tr class="memdesc:ad3d907d9219c652396ff81057de4bae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute surface area of a unit n-ball living in n-dimensional space with n&gt;=2 (this is a n-1 dimensional area); results are cached for O(1) runtime <br /></td></tr>
<tr class="separator:ad3d907d9219c652396ff81057de4bae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4fd0c1095e3805f69c1f5df116ca00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf4fd0c1095e3805f69c1f5df116ca00"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00711.html#acf4fd0c1095e3805f69c1f5df116ca00">compute_sphere_area</a> (unsigned n, double R)</td></tr>
<tr class="memdesc:acf4fd0c1095e3805f69c1f5df116ca00"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute surface area of a n-ball of radius R living in n-dimensional space with n&gt;=2 (this is a n-1 dimensional area); results are cached for O(1) runtime <br /></td></tr>
<tr class="separator:acf4fd0c1095e3805f69c1f5df116ca00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a3b631efe9646ee99ffe54d988391e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a95a3b631efe9646ee99ffe54d988391e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a95a3b631efe9646ee99ffe54d988391e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a95a3b631efe9646ee99ffe54d988391e">erf</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a95a3b631efe9646ee99ffe54d988391e"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate the error function erf(x) = 2/sqrt(Pi)*int(exp(-y^2),y=0..x) <br /></td></tr>
<tr class="separator:a95a3b631efe9646ee99ffe54d988391e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060a402f70bcbd1169cbb1b1e2b273a6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a060a402f70bcbd1169cbb1b1e2b273a6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a060a402f70bcbd1169cbb1b1e2b273a6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a060a402f70bcbd1169cbb1b1e2b273a6">erfc</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a060a402f70bcbd1169cbb1b1e2b273a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate the complementary error function erfc(x) = 1-erf(x) <br /></td></tr>
<tr class="separator:a060a402f70bcbd1169cbb1b1e2b273a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e38d3a09f964017cf36143d2d1f0a9"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad4e38d3a09f964017cf36143d2d1f0a9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad4e38d3a09f964017cf36143d2d1f0a9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ad4e38d3a09f964017cf36143d2d1f0a9">Phi</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ad4e38d3a09f964017cf36143d2d1f0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate the cummulative normal distribution function <br /></td></tr>
<tr class="separator:ad4e38d3a09f964017cf36143d2d1f0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04435f4678d0f753e16f9617551ed2f9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a04435f4678d0f753e16f9617551ed2f9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a04435f4678d0f753e16f9617551ed2f9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a04435f4678d0f753e16f9617551ed2f9">inv_Phi</a> (const T &amp;p)</td></tr>
<tr class="memdesc:a04435f4678d0f753e16f9617551ed2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate the inverse of the error function Phi^(-1)(p), p=0..1 <br /></td></tr>
<tr class="separator:a04435f4678d0f753e16f9617551ed2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa52c4120248159499bc320aba339c5"><td class="memTemplParams" colspan="2"><a class="anchor" id="abfa52c4120248159499bc320aba339c5"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:abfa52c4120248159499bc320aba339c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00108.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#abfa52c4120248159499bc320aba339c5">normalize</a> (const <a class="el" href="a00108.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:abfa52c4120248159499bc320aba339c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">return normalized vector <br /></td></tr>
<tr class="separator:abfa52c4120248159499bc320aba339c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ddde9beff4b995998d2bb2d24b24ba"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad5ddde9beff4b995998d2bb2d24b24ba"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:ad5ddde9beff4b995998d2bb2d24b24ba"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ad5ddde9beff4b995998d2bb2d24b24ba">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="a00108.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:ad5ddde9beff4b995998d2bb2d24b24ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">output of a vector <br /></td></tr>
<tr class="separator:ad5ddde9beff4b995998d2bb2d24b24ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bd49e63d6ae0f26d04c577737eeb07"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad6bd49e63d6ae0f26d04c577737eeb07"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:ad6bd49e63d6ae0f26d04c577737eeb07"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ad6bd49e63d6ae0f26d04c577737eeb07">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="a00108.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:ad6bd49e63d6ae0f26d04c577737eeb07"><td class="mdescLeft">&#160;</td><td class="mdescRight">input of a vector <br /></td></tr>
<tr class="separator:ad6bd49e63d6ae0f26d04c577737eeb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141d32ee8c12656a895f74788ceae9a9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a141d32ee8c12656a895f74788ceae9a9"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a141d32ee8c12656a895f74788ceae9a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00108.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a141d32ee8c12656a895f74788ceae9a9">operator*</a> (const T &amp;s, const <a class="el" href="a00108.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:a141d32ee8c12656a895f74788ceae9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the product of a scalar s and vector v <br /></td></tr>
<tr class="separator:a141d32ee8c12656a895f74788ceae9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb663d99581ddaad548e7dd52946a51"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8cb663d99581ddaad548e7dd52946a51"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a8cb663d99581ddaad548e7dd52946a51"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a8cb663d99581ddaad548e7dd52946a51">dot</a> (const <a class="el" href="a00108.html">fvec</a>&lt; T, N &gt; &amp;v, const <a class="el" href="a00108.html">fvec</a>&lt; T, N &gt; &amp;w)</td></tr>
<tr class="memdesc:a8cb663d99581ddaad548e7dd52946a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the dot product of vector v and w <br /></td></tr>
<tr class="separator:a8cb663d99581ddaad548e7dd52946a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319fcf5471db921fa80eedf62c03ff02"><td class="memTemplParams" colspan="2"><a class="anchor" id="a319fcf5471db921fa80eedf62c03ff02"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a319fcf5471db921fa80eedf62c03ff02"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a319fcf5471db921fa80eedf62c03ff02">length</a> (const <a class="el" href="a00108.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:a319fcf5471db921fa80eedf62c03ff02"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the length of vector v <br /></td></tr>
<tr class="separator:a319fcf5471db921fa80eedf62c03ff02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dec8fec76658745c64947ff97a0915"><td class="memTemplParams" colspan="2"><a class="anchor" id="a98dec8fec76658745c64947ff97a0915"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a98dec8fec76658745c64947ff97a0915"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a98dec8fec76658745c64947ff97a0915">sqr_length</a> (const <a class="el" href="a00108.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:a98dec8fec76658745c64947ff97a0915"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the squared length of vector v <br /></td></tr>
<tr class="separator:a98dec8fec76658745c64947ff97a0915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c477a6a271f0ea40c265e5182c529e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a43c477a6a271f0ea40c265e5182c529e"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a43c477a6a271f0ea40c265e5182c529e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00108.html">fvec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a43c477a6a271f0ea40c265e5182c529e">cross</a> (const <a class="el" href="a00108.html">fvec</a>&lt; T, N &gt; &amp;v, const <a class="el" href="a00108.html">fvec</a>&lt; T, N &gt; &amp;w)</td></tr>
<tr class="memdesc:a43c477a6a271f0ea40c265e5182c529e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the cross product of vector v and w <br /></td></tr>
<tr class="separator:a43c477a6a271f0ea40c265e5182c529e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62eea7ce2b3664181282b42f3de50d8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac62eea7ce2b3664181282b42f3de50d8"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:ac62eea7ce2b3664181282b42f3de50d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00108.html">fvec</a>&lt; T, N+1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ac62eea7ce2b3664181282b42f3de50d8">hom</a> (const <a class="el" href="a00108.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:ac62eea7ce2b3664181282b42f3de50d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the cross product of vector v and w <br /></td></tr>
<tr class="separator:ac62eea7ce2b3664181282b42f3de50d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021c54ae9938e48312e58ba9497336d5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a021c54ae9938e48312e58ba9497336d5"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a021c54ae9938e48312e58ba9497336d5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a021c54ae9938e48312e58ba9497336d5">min_value</a> (const <a class="el" href="a00108.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:a021c54ae9938e48312e58ba9497336d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the minimal entry <br /></td></tr>
<tr class="separator:a021c54ae9938e48312e58ba9497336d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f32aff46cb5d2962caf1123ac1be20"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab9f32aff46cb5d2962caf1123ac1be20"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:ab9f32aff46cb5d2962caf1123ac1be20"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ab9f32aff46cb5d2962caf1123ac1be20">min_index</a> (const <a class="el" href="a00108.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:ab9f32aff46cb5d2962caf1123ac1be20"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the index of the smallest value <br /></td></tr>
<tr class="separator:ab9f32aff46cb5d2962caf1123ac1be20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f496231d4b5519a815e6be9387f851"><td class="memTemplParams" colspan="2"><a class="anchor" id="a92f496231d4b5519a815e6be9387f851"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a92f496231d4b5519a815e6be9387f851"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a92f496231d4b5519a815e6be9387f851">max_index</a> (const <a class="el" href="a00108.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:a92f496231d4b5519a815e6be9387f851"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the index of the largest entry <br /></td></tr>
<tr class="separator:a92f496231d4b5519a815e6be9387f851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f7f6756f02d9477d4522f74dfa0ff4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a94f7f6756f02d9477d4522f74dfa0ff4"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a94f7f6756f02d9477d4522f74dfa0ff4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a94f7f6756f02d9477d4522f74dfa0ff4">max_value</a> (const <a class="el" href="a00108.html">fvec</a>&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:a94f7f6756f02d9477d4522f74dfa0ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the value of the largest entry <br /></td></tr>
<tr class="separator:a94f7f6756f02d9477d4522f74dfa0ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20031ad94f8b2a051428afe3a8ba59d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab20031ad94f8b2a051428afe3a8ba59d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ab20031ad94f8b2a051428afe3a8ba59d">gaussj</a> (<a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;a, <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:ab20031ad94f8b2a051428afe3a8ba59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc42005ee85cb4bf30107636abfe7d6f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afc42005ee85cb4bf30107636abfe7d6f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#afc42005ee85cb4bf30107636abfe7d6f">gaussj</a> (<a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:afc42005ee85cb4bf30107636abfe7d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a67471b6cb15dc2e4fff9139b18231"><td class="memTemplParams" colspan="2"><a class="anchor" id="a30a67471b6cb15dc2e4fff9139b18231"></a>
template&lt;typename T , cgv::type::uint32_type N&gt; </td></tr>
<tr class="memitem:a30a67471b6cb15dc2e4fff9139b18231"><td class="memTemplItemLeft" align="right" valign="top">fmat&lt; T, N, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a30a67471b6cb15dc2e4fff9139b18231">inv</a> (const fmat&lt; T, N, N &gt; &amp;m)</td></tr>
<tr class="memdesc:a30a67471b6cb15dc2e4fff9139b18231"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the inverse of a square matrix <br /></td></tr>
<tr class="separator:a30a67471b6cb15dc2e4fff9139b18231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1403236221a1a8c6f566ac7cd9732fc5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1403236221a1a8c6f566ac7cd9732fc5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1403236221a1a8c6f566ac7cd9732fc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a1403236221a1a8c6f566ac7cd9732fc5">inv_22</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a1403236221a1a8c6f566ac7cd9732fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute inverse of 2x2 matrix <br /></td></tr>
<tr class="separator:a1403236221a1a8c6f566ac7cd9732fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae382499dd181b0f1f48d0f2e1a9763ce"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae382499dd181b0f1f48d0f2e1a9763ce"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae382499dd181b0f1f48d0f2e1a9763ce"><td class="memTemplItemLeft" align="right" valign="top">fmat&lt; T, 2, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ae382499dd181b0f1f48d0f2e1a9763ce">inv_22</a> (const fmat&lt; T, 3, 3 &gt; &amp;m)</td></tr>
<tr class="memdesc:ae382499dd181b0f1f48d0f2e1a9763ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute inverse of 2x2 matrix <br /></td></tr>
<tr class="separator:ae382499dd181b0f1f48d0f2e1a9763ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504b47389f53413b2111f2c61865e37e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a504b47389f53413b2111f2c61865e37e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a504b47389f53413b2111f2c61865e37e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a504b47389f53413b2111f2c61865e37e">inv_33</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a504b47389f53413b2111f2c61865e37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute inverse of 3x3 matrix <br /></td></tr>
<tr class="separator:a504b47389f53413b2111f2c61865e37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bedfeea66cf56fd1bdc9441ffd1caf4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2bedfeea66cf56fd1bdc9441ffd1caf4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2bedfeea66cf56fd1bdc9441ffd1caf4"><td class="memTemplItemLeft" align="right" valign="top">fmat&lt; T, 3, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a2bedfeea66cf56fd1bdc9441ffd1caf4">inv_33</a> (const fmat&lt; T, 3, 3 &gt; &amp;m)</td></tr>
<tr class="memdesc:a2bedfeea66cf56fd1bdc9441ffd1caf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute inverse of 3x3 matrix <br /></td></tr>
<tr class="separator:a2bedfeea66cf56fd1bdc9441ffd1caf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627d83610f33d7bbff7d122e789aef12"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a627d83610f33d7bbff7d122e789aef12"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a627d83610f33d7bbff7d122e789aef12">solve</a> (const up_tri_mat&lt; T &gt; &amp;a, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;b, <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a627d83610f33d7bbff7d122e789aef12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bda1596ebd16a5de9f634a723a7f9df"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0bda1596ebd16a5de9f634a723a7f9df"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a0bda1596ebd16a5de9f634a723a7f9df">solve</a> (const up_tri_mat&lt; T &gt; &amp;a, const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;b, <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a0bda1596ebd16a5de9f634a723a7f9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e78544b79524eecd69073952b0482f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2e78544b79524eecd69073952b0482f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ad2e78544b79524eecd69073952b0482f">solve</a> (const low_tri_mat&lt; T &gt; &amp;a, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;b, <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ad2e78544b79524eecd69073952b0482f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296626461f44b387652e79b84cba2457"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a296626461f44b387652e79b84cba2457"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a296626461f44b387652e79b84cba2457">solve</a> (const low_tri_mat&lt; T &gt; &amp;a, const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;b, <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a296626461f44b387652e79b84cba2457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c0b1e4eef5446ab6a31bb7e568a301"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a14c0b1e4eef5446ab6a31bb7e568a301"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a14c0b1e4eef5446ab6a31bb7e568a301">solve</a> (const <a class="el" href="a00106.html">diag_mat</a>&lt; T &gt; &amp;a, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;b, <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a14c0b1e4eef5446ab6a31bb7e568a301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1751b115b38d5f2219959166602e39"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afa1751b115b38d5f2219959166602e39"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#afa1751b115b38d5f2219959166602e39">solve</a> (const <a class="el" href="a00123.html">tri_diag_mat</a>&lt; T &gt; &amp;a, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;b, <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:afa1751b115b38d5f2219959166602e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944f8054ed5b163753b2be3da53535d4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a944f8054ed5b163753b2be3da53535d4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a944f8054ed5b163753b2be3da53535d4">solve</a> (const <a class="el" href="a00106.html">diag_mat</a>&lt; T &gt; &amp;a, const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;b, <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a944f8054ed5b163753b2be3da53535d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8063281c4be8efe218d82682385a62"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e8063281c4be8efe218d82682385a62"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a0e8063281c4be8efe218d82682385a62">solve</a> (const <a class="el" href="a00112.html">perm_mat</a> &amp;a, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;b, <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a0e8063281c4be8efe218d82682385a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a0d8e1da5521d3dbcad991e8f20649"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a28a0d8e1da5521d3dbcad991e8f20649"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a28a0d8e1da5521d3dbcad991e8f20649">solve</a> (const <a class="el" href="a00112.html">perm_mat</a> &amp;a, const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;b, <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a28a0d8e1da5521d3dbcad991e8f20649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51224bf488aae401d2056c703e4ac56a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51224bf488aae401d2056c703e4ac56a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a51224bf488aae401d2056c703e4ac56a">lu_solve</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;a, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;b, <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a51224bf488aae401d2056c703e4ac56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4191d37dabc43d6cbc7e5da4dc8f3edd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4191d37dabc43d6cbc7e5da4dc8f3edd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a4191d37dabc43d6cbc7e5da4dc8f3edd">solve</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;a, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;b, <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a4191d37dabc43d6cbc7e5da4dc8f3edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667e247eda3efd7411015db02d15a111"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a667e247eda3efd7411015db02d15a111"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a667e247eda3efd7411015db02d15a111">lu_solve</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;a, const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;b, <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a667e247eda3efd7411015db02d15a111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f874a4044596e0d7f8c4e77e59f4fb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af1f874a4044596e0d7f8c4e77e59f4fb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#af1f874a4044596e0d7f8c4e77e59f4fb">solve</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;a, const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;b, <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:af1f874a4044596e0d7f8c4e77e59f4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36ab77a746697862a6c5887fb985b60"><td class="memTemplParams" colspan="2"><a class="anchor" id="af36ab77a746697862a6c5887fb985b60"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af36ab77a746697862a6c5887fb985b60"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#af36ab77a746697862a6c5887fb985b60">qr_solve</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;a, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;b, <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:af36ab77a746697862a6c5887fb985b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">solve ax=b with qr decomposition <br /></td></tr>
<tr class="separator:af36ab77a746697862a6c5887fb985b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39153e84c1ba0d7cd907ea31a1897f0b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a39153e84c1ba0d7cd907ea31a1897f0b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a39153e84c1ba0d7cd907ea31a1897f0b">qr_solve</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;a, const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;b, <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a39153e84c1ba0d7cd907ea31a1897f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbdf6fbf49a08e616601b2ac1a7895b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5dbdf6fbf49a08e616601b2ac1a7895b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5dbdf6fbf49a08e616601b2ac1a7895b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a5dbdf6fbf49a08e616601b2ac1a7895b">svd_solve</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;a, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;b, <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a5dbdf6fbf49a08e616601b2ac1a7895b"><td class="mdescLeft">&#160;</td><td class="mdescRight">solve ax=b with svd decomposition <br /></td></tr>
<tr class="separator:a5dbdf6fbf49a08e616601b2ac1a7895b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c3d68b3185b9031190ee28d1b627dc"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab3c3d68b3185b9031190ee28d1b627dc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab3c3d68b3185b9031190ee28d1b627dc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ab3c3d68b3185b9031190ee28d1b627dc">svd_solve</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;a, const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;b, <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:ab3c3d68b3185b9031190ee28d1b627dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">solve ax=b with svd decomposition <br /></td></tr>
<tr class="separator:ab3c3d68b3185b9031190ee28d1b627dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ef4f4081f46949400e12412536d4ff"><td class="memTemplParams" colspan="2"><a class="anchor" id="a58ef4f4081f46949400e12412536d4ff"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a58ef4f4081f46949400e12412536d4ff"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a58ef4f4081f46949400e12412536d4ff">operator&lt;&lt;</a> (std::ostream &amp;out, const low_tri_mat&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a58ef4f4081f46949400e12412536d4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">output of a lower triangular matrix onto an ostream <br /></td></tr>
<tr class="separator:a58ef4f4081f46949400e12412536d4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e136f0e04d838c812480264371ed1be"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1e136f0e04d838c812480264371ed1be"></a>
template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a1e136f0e04d838c812480264371ed1be"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a1e136f0e04d838c812480264371ed1be">operator*</a> (const low_tri_mat&lt; T &gt; &amp;m1, const low_tri_mat&lt; S &gt; &amp;m2)</td></tr>
<tr class="memdesc:a1e136f0e04d838c812480264371ed1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplication of two lower triangular matrices <br /></td></tr>
<tr class="separator:a1e136f0e04d838c812480264371ed1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb40b8cf269e19d2dd02c8e5d7f2605"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abbb40b8cf269e19d2dd02c8e5d7f2605"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#abbb40b8cf269e19d2dd02c8e5d7f2605">lu</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;a, <a class="el" href="a00112.html">perm_mat</a> &amp;p, low_tri_mat&lt; T &gt; &amp;l, up_tri_mat&lt; T &gt; &amp;u)</td></tr>
<tr class="separator:abbb40b8cf269e19d2dd02c8e5d7f2605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dff5987034becd48b49ff280d63b8fe"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4dff5987034becd48b49ff280d63b8fe"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4dff5987034becd48b49ff280d63b8fe"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a4dff5987034becd48b49ff280d63b8fe">ceil</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a4dff5987034becd48b49ff280d63b8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">ceil all components of the matrix <br /></td></tr>
<tr class="separator:a4dff5987034becd48b49ff280d63b8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93aee66ad9e05a128e33680753b5705a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a93aee66ad9e05a128e33680753b5705a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a93aee66ad9e05a128e33680753b5705a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a93aee66ad9e05a128e33680753b5705a">floor</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a93aee66ad9e05a128e33680753b5705a"><td class="mdescLeft">&#160;</td><td class="mdescRight">floor all components of the matrix <br /></td></tr>
<tr class="separator:a93aee66ad9e05a128e33680753b5705a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348ea2051480f9e505e5aae599493074"><td class="memTemplParams" colspan="2"><a class="anchor" id="a348ea2051480f9e505e5aae599493074"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a348ea2051480f9e505e5aae599493074"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a348ea2051480f9e505e5aae599493074">round</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a348ea2051480f9e505e5aae599493074"><td class="mdescLeft">&#160;</td><td class="mdescRight">round all components of the matrix <br /></td></tr>
<tr class="separator:a348ea2051480f9e505e5aae599493074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750d95c2509cf60ee60e33443412e13f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a750d95c2509cf60ee60e33443412e13f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a750d95c2509cf60ee60e33443412e13f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a750d95c2509cf60ee60e33443412e13f">operator*</a> (const T &amp;s, const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a750d95c2509cf60ee60e33443412e13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the product of a scalar s and a matrix m <br /></td></tr>
<tr class="separator:a750d95c2509cf60ee60e33443412e13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9075b0df2e84047b5eccc4dfff7931d0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9075b0df2e84047b5eccc4dfff7931d0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9075b0df2e84047b5eccc4dfff7931d0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a9075b0df2e84047b5eccc4dfff7931d0">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a9075b0df2e84047b5eccc4dfff7931d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">output of a matrix onto an ostream <br /></td></tr>
<tr class="separator:a9075b0df2e84047b5eccc4dfff7931d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0ec942d309201e672426563a171cd8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5f0ec942d309201e672426563a171cd8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5f0ec942d309201e672426563a171cd8"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a5f0ec942d309201e672426563a171cd8">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a5f0ec942d309201e672426563a171cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">input of a matrix onto an ostream <br /></td></tr>
<tr class="separator:a5f0ec942d309201e672426563a171cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f884462214d37af98d55984170fb1c5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2f884462214d37af98d55984170fb1c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a2f884462214d37af98d55984170fb1c5">Atx</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;a, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;x, <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;atx)</td></tr>
<tr class="separator:a2f884462214d37af98d55984170fb1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82788036c8f08a2cdce123c0717c6b2"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa82788036c8f08a2cdce123c0717c6b2"></a>
template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:aa82788036c8f08a2cdce123c0717c6b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#aa82788036c8f08a2cdce123c0717c6b2">dyad</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v, const <a class="el" href="a00127.html">vec</a>&lt; S &gt; &amp;w)</td></tr>
<tr class="memdesc:aa82788036c8f08a2cdce123c0717c6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the outer product of vector v and w <br /></td></tr>
<tr class="separator:aa82788036c8f08a2cdce123c0717c6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412054fabb1f60c7076fb8f714dbe77b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a412054fabb1f60c7076fb8f714dbe77b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a412054fabb1f60c7076fb8f714dbe77b">AIC</a> (int k, const T &amp;L)</td></tr>
<tr class="separator:a412054fabb1f60c7076fb8f714dbe77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c949211e1bdcfb28758a678bdf06b5d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c949211e1bdcfb28758a678bdf06b5d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a7c949211e1bdcfb28758a678bdf06b5d">AIC_ls</a> (int k, int n, const T &amp;RSS)</td></tr>
<tr class="separator:a7c949211e1bdcfb28758a678bdf06b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c70cac0aed64ef9cb752790c0c1a23"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa3c70cac0aed64ef9cb752790c0c1a23"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#aa3c70cac0aed64ef9cb752790c0c1a23">AICc</a> (int k, int n, const T &amp;L)</td></tr>
<tr class="separator:aa3c70cac0aed64ef9cb752790c0c1a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93ba61da7f07c4a49a79060d92a28ef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab93ba61da7f07c4a49a79060d92a28ef"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ab93ba61da7f07c4a49a79060d92a28ef">AICc_ls</a> (int k, int n, const T &amp;RSS)</td></tr>
<tr class="separator:ab93ba61da7f07c4a49a79060d92a28ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5ea1af956e9651fccbedf5419f7adf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aae5ea1af956e9651fccbedf5419f7adf"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#aae5ea1af956e9651fccbedf5419f7adf">AICu_ls</a> (int k, int n, const T &amp;RSS)</td></tr>
<tr class="separator:aae5ea1af956e9651fccbedf5419f7adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5c2da55ba6e9caaac77a70bec26e92"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef5c2da55ba6e9caaac77a70bec26e92"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#aef5c2da55ba6e9caaac77a70bec26e92">BIC</a> (int k, int n, const T &amp;L)</td></tr>
<tr class="separator:aef5c2da55ba6e9caaac77a70bec26e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4d7e7d0b479a4fcf81fd38af9fda4b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace4d7e7d0b479a4fcf81fd38af9fda4b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ace4d7e7d0b479a4fcf81fd38af9fda4b">BIC_ls</a> (int k, int n, const T &amp;RSS)</td></tr>
<tr class="separator:ace4d7e7d0b479a4fcf81fd38af9fda4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72df463c830e9334b8903566afb95fb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00711.html#a72df463c830e9334b8903566afb95fb4">estimate_normal_ls</a> (unsigned nr_points, const float *_points, float *_normal, float *_evals=0, float *_mean=0, float *_evecs=0)</td></tr>
<tr class="memdesc:a72df463c830e9334b8903566afb95fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute least squares normal from an array of 3D points.  <a href="#a72df463c830e9334b8903566afb95fb4">More...</a><br /></td></tr>
<tr class="separator:a72df463c830e9334b8903566afb95fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1e437b67fa2ac3e34fa7643a0d8eac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b1e437b67fa2ac3e34fa7643a0d8eac"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00711.html#a3b1e437b67fa2ac3e34fa7643a0d8eac">estimate_normal_wls</a> (unsigned nr_points, const float *_points, const float *_weights, float *_normal, float *_evals=0, float *_mean=0, float *_evecs=0)</td></tr>
<tr class="memdesc:a3b1e437b67fa2ac3e34fa7643a0d8eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighted version of <code>estimate_normal_ls</code> with additional input <code>_weights</code> pointing to <code>nr_points</code> scalar weights. <br /></td></tr>
<tr class="separator:a3b1e437b67fa2ac3e34fa7643a0d8eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed94b33c020f613384ed757f032e7b8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6ed94b33c020f613384ed757f032e7b8"></a>
template&lt;typename T , typename I &gt; </td></tr>
<tr class="memitem:a6ed94b33c020f613384ed757f032e7b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a6ed94b33c020f613384ed757f032e7b8">permute_array</a> (size_t N, T *A, I *P)</td></tr>
<tr class="memdesc:a6ed94b33c020f613384ed757f032e7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">permute array <code>A</code> with <code>N</code> values of type <code>T</code> according to permutation <code>P</code> such that <code>A</code>[i] moves to <code>A</code>[P[i]] <br /></td></tr>
<tr class="separator:a6ed94b33c020f613384ed757f032e7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b277b91cc121749e9c2de21e4e0806"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad9b277b91cc121749e9c2de21e4e0806"></a>
template&lt;typename T , typename I &gt; </td></tr>
<tr class="memitem:ad9b277b91cc121749e9c2de21e4e0806"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ad9b277b91cc121749e9c2de21e4e0806">permute_vector</a> (std::vector&lt; T &gt; &amp;V, std::vector&lt; I &gt; &amp;P)</td></tr>
<tr class="memdesc:ad9b277b91cc121749e9c2de21e4e0806"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface to permute function for arrays and permutations stored in vectors <br /></td></tr>
<tr class="separator:ad9b277b91cc121749e9c2de21e4e0806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533e215a27ea03a63a404cd7c2286a98"><td class="memTemplParams" colspan="2"><a class="anchor" id="a533e215a27ea03a63a404cd7c2286a98"></a>
template&lt;typename T , typename I &gt; </td></tr>
<tr class="memitem:a533e215a27ea03a63a404cd7c2286a98"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a533e215a27ea03a63a404cd7c2286a98">permute_arrays</a> (T *data, I *P, size_t nr_rows, size_t nr_columns, size_t row_step, size_t column_step)</td></tr>
<tr class="memdesc:a533e215a27ea03a63a404cd7c2286a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">permute <code>nr_rows</code> rows of nested 2D array with <code>nr_columns</code> columns, step sizes to step by one row / column need to be provided <br /></td></tr>
<tr class="separator:a533e215a27ea03a63a404cd7c2286a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa33183d42422e47e25d8c55bbc9faa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6fa33183d42422e47e25d8c55bbc9faa"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a6fa33183d42422e47e25d8c55bbc9faa">plane_val</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;plane, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a6fa33183d42422e47e25d8c55bbc9faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f68ed2925f866ed12dbc4b043b104a2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1f68ed2925f866ed12dbc4b043b104a2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f68ed2925f866ed12dbc4b043b104a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a1f68ed2925f866ed12dbc4b043b104a2">plane_val</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;plane, const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;xs)</td></tr>
<tr class="memdesc:a1f68ed2925f866ed12dbc4b043b104a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate plame equation on multiple positions xs <br /></td></tr>
<tr class="separator:a1f68ed2925f866ed12dbc4b043b104a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980c68f5c243fa1a32c157ff23041952"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a980c68f5c243fa1a32c157ff23041952"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a980c68f5c243fa1a32c157ff23041952">ransac_plane_fit</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;points, const T p_out=0.8, const T d_max=0.001, const T p_surety=0.99, bool msac=true)</td></tr>
<tr class="separator:a980c68f5c243fa1a32c157ff23041952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11a737a3535c089fc6ba9c5970d399d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab11a737a3535c089fc6ba9c5970d399d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab11a737a3535c089fc6ba9c5970d399d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ab11a737a3535c089fc6ba9c5970d399d">mean</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;points)</td></tr>
<tr class="memdesc:ab11a737a3535c089fc6ba9c5970d399d"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the mean of all column vectors <br /></td></tr>
<tr class="separator:ab11a737a3535c089fc6ba9c5970d399d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47423e8f43fdf220cc4baea42c5360c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab47423e8f43fdf220cc4baea42c5360c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">cgv::math::vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ab47423e8f43fdf220cc4baea42c5360c">geometric_median</a> (const <a class="el" href="a00110.html">cgv::math::mat</a>&lt; T &gt; &amp;points, const T &amp;eps=0.0001, const unsigned max_iter=100)</td></tr>
<tr class="separator:ab47423e8f43fdf220cc4baea42c5360c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75402440f907260dc42b4eddb0caa4f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad75402440f907260dc42b4eddb0caa4f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad75402440f907260dc42b4eddb0caa4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ad75402440f907260dc42b4eddb0caa4f">weighted_mean</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;weights, const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;points)</td></tr>
<tr class="memdesc:ad75402440f907260dc42b4eddb0caa4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the weighted mean of all column vectors <br /></td></tr>
<tr class="separator:ad75402440f907260dc42b4eddb0caa4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4720e06972baa64a69acb0bb8b8d3e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3f4720e06972baa64a69acb0bb8b8d3e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3f4720e06972baa64a69acb0bb8b8d3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a3f4720e06972baa64a69acb0bb8b8d3e">covmat</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;points)</td></tr>
<tr class="memdesc:a3f4720e06972baa64a69acb0bb8b8d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute covariance matrix of the column vectors of points <br /></td></tr>
<tr class="separator:a3f4720e06972baa64a69acb0bb8b8d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a43b507e6de46542c40ad378471557"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac5a43b507e6de46542c40ad378471557"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac5a43b507e6de46542c40ad378471557"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ac5a43b507e6de46542c40ad378471557">weighted_covmat</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;weights, const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;points)</td></tr>
<tr class="memdesc:ac5a43b507e6de46542c40ad378471557"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute weighted covariance matrix of the column vectors of points <br /></td></tr>
<tr class="separator:ac5a43b507e6de46542c40ad378471557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6160ff5a9e773979900dc4a6f54f8330"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6160ff5a9e773979900dc4a6f54f8330"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6160ff5a9e773979900dc4a6f54f8330"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a6160ff5a9e773979900dc4a6f54f8330">weighted_covmat_and_mean</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;weights, const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;points, <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;wcovmat, <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;wmean)</td></tr>
<tr class="memdesc:a6160ff5a9e773979900dc4a6f54f8330"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute covariance matrix and mean of the column vectors of points in one step <br /></td></tr>
<tr class="separator:a6160ff5a9e773979900dc4a6f54f8330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add56cb42b150686bf69c39de5b71ae4b"><td class="memTemplParams" colspan="2"><a class="anchor" id="add56cb42b150686bf69c39de5b71ae4b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:add56cb42b150686bf69c39de5b71ae4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#add56cb42b150686bf69c39de5b71ae4b">covmat_and_mean</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;points, <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;<a class="el" href="a00711.html#a3f4720e06972baa64a69acb0bb8b8d3e">covmat</a>, <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;<a class="el" href="a00711.html#ab11a737a3535c089fc6ba9c5970d399d">mean</a>)</td></tr>
<tr class="memdesc:add56cb42b150686bf69c39de5b71ae4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute covariance matrix and mean of the column vectors of points in one step <br /></td></tr>
<tr class="separator:add56cb42b150686bf69c39de5b71ae4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41efc72e1a7aad03a48a289c7fad23c8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a41efc72e1a7aad03a48a289c7fad23c8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a41efc72e1a7aad03a48a289c7fad23c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a41efc72e1a7aad03a48a289c7fad23c8">swap_XYZ_2_XZY</a> (<a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;points)</td></tr>
<tr class="memdesc:a41efc72e1a7aad03a48a289c7fad23c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap second with third row of point matrix <br /></td></tr>
<tr class="separator:a41efc72e1a7aad03a48a289c7fad23c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740272723e8fd8a035b306d85b0b1e3f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a740272723e8fd8a035b306d85b0b1e3f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a740272723e8fd8a035b306d85b0b1e3f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a740272723e8fd8a035b306d85b0b1e3f">homog</a> (<a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;points)</td></tr>
<tr class="memdesc:a740272723e8fd8a035b306d85b0b1e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a set of non-homogeneous points into homogeneous points. <br /></td></tr>
<tr class="separator:a740272723e8fd8a035b306d85b0b1e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec60c75ddff3f844d673f8147410106"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9ec60c75ddff3f844d673f8147410106"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ec60c75ddff3f844d673f8147410106"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a9ec60c75ddff3f844d673f8147410106">unhomog</a> (<a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;points)</td></tr>
<tr class="memdesc:a9ec60c75ddff3f844d673f8147410106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a set of homogeneous points into non-homogeneous points by dividing with the last component. <br /></td></tr>
<tr class="separator:a9ec60c75ddff3f844d673f8147410106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227ca8bca8d01aa6cad1f74c79994f2c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a227ca8bca8d01aa6cad1f74c79994f2c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a227ca8bca8d01aa6cad1f74c79994f2c">polar</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;c, <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;r, <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;a, int num_iter=15)</td></tr>
<tr class="separator:a227ca8bca8d01aa6cad1f74c79994f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13d980b9726467aeb59b55256fedda0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad13d980b9726467aeb59b55256fedda0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ad13d980b9726467aeb59b55256fedda0">decompose_rotation</a> (const <a class="el" href="a00110.html">cgv::math::mat</a>&lt; T &gt; &amp;R, <a class="el" href="a00127.html">cgv::math::vec</a>&lt; T &gt; &amp;axis, T &amp;angle)</td></tr>
<tr class="separator:ad13d980b9726467aeb59b55256fedda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f72457452fa12679ad840de7b06df1c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9f72457452fa12679ad840de7b06df1c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a9f72457452fa12679ad840de7b06df1c">poly_val</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;p, const T &amp;x)</td></tr>
<tr class="separator:a9f72457452fa12679ad840de7b06df1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556f6aef31de955ddca54cf92650b5f4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a556f6aef31de955ddca54cf92650b5f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a556f6aef31de955ddca54cf92650b5f4">poly_val</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;p, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a556f6aef31de955ddca54cf92650b5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8848108dc554c9e2d68c8ee728126e33"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8848108dc554c9e2d68c8ee728126e33"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8848108dc554c9e2d68c8ee728126e33"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a8848108dc554c9e2d68c8ee728126e33">poly_mult</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;u, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a8848108dc554c9e2d68c8ee728126e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">1d convolution or polynomial multiplication <br /></td></tr>
<tr class="separator:a8848108dc554c9e2d68c8ee728126e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edb1c4b430e362c3cf62aae108746b5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9edb1c4b430e362c3cf62aae108746b5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a9edb1c4b430e362c3cf62aae108746b5">poly_div</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;f, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;g, <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;q, <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;r)</td></tr>
<tr class="separator:a9edb1c4b430e362c3cf62aae108746b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec5e342963d8b8db068c541d386f71f"><td class="memTemplParams" colspan="2"><a class="anchor" id="adec5e342963d8b8db068c541d386f71f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adec5e342963d8b8db068c541d386f71f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#adec5e342963d8b8db068c541d386f71f">bernstein_polynomial</a> (unsigned j, unsigned g)</td></tr>
<tr class="memdesc:adec5e342963d8b8db068c541d386f71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns bernstein polynomial (bezier basis) <br /></td></tr>
<tr class="separator:adec5e342963d8b8db068c541d386f71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea16e699f66a3153080cf69a50b9146"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5ea16e699f66a3153080cf69a50b9146"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5ea16e699f66a3153080cf69a50b9146"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00113.html">qem</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a5ea16e699f66a3153080cf69a50b9146">operator*</a> (const T &amp;s, const <a class="el" href="a00113.html">qem</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a5ea16e699f66a3153080cf69a50b9146"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the product of a scalar s and qem v <br /></td></tr>
<tr class="separator:a5ea16e699f66a3153080cf69a50b9146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80c8817a7542063b7bb3bc47860ede6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac80c8817a7542063b7bb3bc47860ede6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ac80c8817a7542063b7bb3bc47860ede6">quat_multiply</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;q)</td></tr>
<tr class="separator:ac80c8817a7542063b7bb3bc47860ede6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ff4fb26f360378f4a2dce97875f671"><td class="memTemplParams" colspan="2"><a class="anchor" id="a16ff4fb26f360378f4a2dce97875f671"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a16ff4fb26f360378f4a2dce97875f671"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a16ff4fb26f360378f4a2dce97875f671">axis_angle_2_quat</a> (<a class="el" href="a00127.html">vec</a>&lt; T &gt; axis, T angle)</td></tr>
<tr class="memdesc:a16ff4fb26f360378f4a2dce97875f671"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a quaterion q defined by the given axis and angle <br /></td></tr>
<tr class="separator:a16ff4fb26f360378f4a2dce97875f671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e17e86fbb77d2e81c3955d56b666ea6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4e17e86fbb77d2e81c3955d56b666ea6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4e17e86fbb77d2e81c3955d56b666ea6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a4e17e86fbb77d2e81c3955d56b666ea6">quat_2_axis_angle</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;q, <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;axis, T &amp;angle)</td></tr>
<tr class="memdesc:a4e17e86fbb77d2e81c3955d56b666ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract the axis and angle in degree from quaternion q <br /></td></tr>
<tr class="separator:a4e17e86fbb77d2e81c3955d56b666ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91fb0987f4f9ded50a594aea9c052a5d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a91fb0987f4f9ded50a594aea9c052a5d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91fb0987f4f9ded50a594aea9c052a5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a91fb0987f4f9ded50a594aea9c052a5d">quat_rotate</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;q, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a91fb0987f4f9ded50a594aea9c052a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the rotation of vector v by quaternion q <br /></td></tr>
<tr class="separator:a91fb0987f4f9ded50a594aea9c052a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148f0a4608ecd5d41bc6ffc1b83c11f3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a148f0a4608ecd5d41bc6ffc1b83c11f3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a148f0a4608ecd5d41bc6ffc1b83c11f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a148f0a4608ecd5d41bc6ffc1b83c11f3">quat_conj</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;q)</td></tr>
<tr class="memdesc:a148f0a4608ecd5d41bc6ffc1b83c11f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the conjugate quaternion q <br /></td></tr>
<tr class="separator:a148f0a4608ecd5d41bc6ffc1b83c11f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2818f7c5d47390e87b50fe008452b0"><td class="memTemplParams" colspan="2"><a class="anchor" id="afa2818f7c5d47390e87b50fe008452b0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afa2818f7c5d47390e87b50fe008452b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#afa2818f7c5d47390e87b50fe008452b0">quat_normalize</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;q)</td></tr>
<tr class="memdesc:afa2818f7c5d47390e87b50fe008452b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a normalize version of quaternion q <br /></td></tr>
<tr class="separator:afa2818f7c5d47390e87b50fe008452b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d67840aca927a20bc061ff724401ea"><td class="memTemplParams" colspan="2"><a class="anchor" id="a62d67840aca927a20bc061ff724401ea"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a62d67840aca927a20bc061ff724401ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a62d67840aca927a20bc061ff724401ea">quat_inv</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;q)</td></tr>
<tr class="memdesc:a62d67840aca927a20bc061ff724401ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the inverse of quaterion q <br /></td></tr>
<tr class="separator:a62d67840aca927a20bc061ff724401ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81aff26fbcb622a458ea9ad3f053c9e2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a81aff26fbcb622a458ea9ad3f053c9e2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a81aff26fbcb622a458ea9ad3f053c9e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a81aff26fbcb622a458ea9ad3f053c9e2">quat_2_mat_33</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;q)</td></tr>
<tr class="memdesc:a81aff26fbcb622a458ea9ad3f053c9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert unit quaternion to 3x3 rotation matrix <br /></td></tr>
<tr class="separator:a81aff26fbcb622a458ea9ad3f053c9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fcb46517f4106ddcfd5b2a2fd256ff"><td class="memTemplParams" colspan="2"><a class="anchor" id="a24fcb46517f4106ddcfd5b2a2fd256ff"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a24fcb46517f4106ddcfd5b2a2fd256ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a24fcb46517f4106ddcfd5b2a2fd256ff">quat_2_mat_44</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;q)</td></tr>
<tr class="memdesc:a24fcb46517f4106ddcfd5b2a2fd256ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert unit quaternion to 4x4 rotation matrix <br /></td></tr>
<tr class="separator:a24fcb46517f4106ddcfd5b2a2fd256ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1134ce876e614d9d0484700d45bb0e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1b1134ce876e614d9d0484700d45bb0e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1b1134ce876e614d9d0484700d45bb0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00114.html">quaternion</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a1b1134ce876e614d9d0484700d45bb0e">operator*</a> (const T &amp;s, const <a class="el" href="a00114.html">quaternion</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a1b1134ce876e614d9d0484700d45bb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the product of a scalar s and vector v <br /></td></tr>
<tr class="separator:a1b1134ce876e614d9d0484700d45bb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272db28d4d7d4cc2f6e608c50918a664"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a272db28d4d7d4cc2f6e608c50918a664"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a272db28d4d7d4cc2f6e608c50918a664">num_ransac_iterations</a> (unsigned n_min, const T p_out, const T p_surety=0.99)</td></tr>
<tr class="separator:a272db28d4d7d4cc2f6e608c50918a664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fe68403e329af9ace512b1d945bb53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4fe68403e329af9ace512b1d945bb53"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00711.html#ae4fe68403e329af9ace512b1d945bb53">solve_quadric</a> (double c[3], double s[2], bool replicate_multiple_solutions=false)</td></tr>
<tr class="memdesc:ae4fe68403e329af9ace512b1d945bb53"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the solutions to c[0]+c[1]*x+c[2]*x*x = 0 into s and return the number of solutions <br /></td></tr>
<tr class="separator:ae4fe68403e329af9ace512b1d945bb53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a18eac44663bd5bff968c8a98ad4b1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a18eac44663bd5bff968c8a98ad4b1b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00711.html#a2a18eac44663bd5bff968c8a98ad4b1b">solve_cubic</a> (double c[4], double s[3], bool replicate_multiple_solutions=false)</td></tr>
<tr class="memdesc:a2a18eac44663bd5bff968c8a98ad4b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the solutions to c[0]+c[1]*x+c[2]*x*x+c[3]*x*x*x = 0 into s and return the number of solutions <br /></td></tr>
<tr class="separator:a2a18eac44663bd5bff968c8a98ad4b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc0e7b7f9374468390e175c7c8d719c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aadc0e7b7f9374468390e175c7c8d719c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00711.html#aadc0e7b7f9374468390e175c7c8d719c">solve_quartic</a> (double c[5], double s[4])</td></tr>
<tr class="memdesc:aadc0e7b7f9374468390e175c7c8d719c"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the solutions to c[0]+c[1]*x+c[2]*x*x+c[3]*x*x*x+c[4]*x*x*x*x = 0 into s and return the number of solutions <br /></td></tr>
<tr class="separator:aadc0e7b7f9374468390e175c7c8d719c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f80cfa8700f246807ae76fa63bbc1e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa0f80cfa8700f246807ae76fa63bbc1e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#aa0f80cfa8700f246807ae76fa63bbc1e">sphere_val</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;sphere, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aa0f80cfa8700f246807ae76fa63bbc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6452e4900f24398889506f6d1625a0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1c6452e4900f24398889506f6d1625a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a1c6452e4900f24398889506f6d1625a0">sphere_val</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;sphere, const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;xs)</td></tr>
<tr class="separator:a1c6452e4900f24398889506f6d1625a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c64d492a52f234bd13234c434c12c39"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2c64d492a52f234bd13234c434c12c39"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a2c64d492a52f234bd13234c434c12c39">sphere_val2</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;sphere, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a2c64d492a52f234bd13234c434c12c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc48a1fe7f24ebdc9910d2bf512e6908"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc48a1fe7f24ebdc9910d2bf512e6908"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#acc48a1fe7f24ebdc9910d2bf512e6908">sphere_val2</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;sphere, const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;xs)</td></tr>
<tr class="separator:acc48a1fe7f24ebdc9910d2bf512e6908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83af4b14f8e4dbc6cdc8dcaa66d5f0e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad83af4b14f8e4dbc6cdc8dcaa66d5f0e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad83af4b14f8e4dbc6cdc8dcaa66d5f0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ad83af4b14f8e4dbc6cdc8dcaa66d5f0e">sphere_fit</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;p1)</td></tr>
<tr class="memdesc:ad83af4b14f8e4dbc6cdc8dcaa66d5f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct smallest enclosing sphere of one point <br /></td></tr>
<tr class="separator:ad83af4b14f8e4dbc6cdc8dcaa66d5f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af977cf5721c056df0c03918934c41eec"><td class="memTemplParams" colspan="2"><a class="anchor" id="af977cf5721c056df0c03918934c41eec"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af977cf5721c056df0c03918934c41eec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#af977cf5721c056df0c03918934c41eec">sphere_fit</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;p1, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;p2)</td></tr>
<tr class="memdesc:af977cf5721c056df0c03918934c41eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">sphere through 2 points <br /></td></tr>
<tr class="separator:af977cf5721c056df0c03918934c41eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60162fd6544ef9225c3d0680266a84f7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a60162fd6544ef9225c3d0680266a84f7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a60162fd6544ef9225c3d0680266a84f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a60162fd6544ef9225c3d0680266a84f7">sphere_fit</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;O, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;A, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;B)</td></tr>
<tr class="memdesc:a60162fd6544ef9225c3d0680266a84f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">sphere through 3 points <br /></td></tr>
<tr class="separator:a60162fd6544ef9225c3d0680266a84f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa668eda4b3e0077fdeced5dfac9652c6"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa668eda4b3e0077fdeced5dfac9652c6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa668eda4b3e0077fdeced5dfac9652c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#aa668eda4b3e0077fdeced5dfac9652c6">sphere_fit</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;x1, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;x2, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;x3, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;x4)</td></tr>
<tr class="memdesc:aa668eda4b3e0077fdeced5dfac9652c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">sphere through 4 points <br /></td></tr>
<tr class="separator:aa668eda4b3e0077fdeced5dfac9652c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13036c077a8de74c02b7646d08012c04"><td class="memTemplParams" colspan="2"><a class="anchor" id="a13036c077a8de74c02b7646d08012c04"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a13036c077a8de74c02b7646d08012c04"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a13036c077a8de74c02b7646d08012c04">mini_ball</a> (<a class="el" href="a00110.html">cgv::math::mat</a>&lt; T &gt; &amp;points)</td></tr>
<tr class="memdesc:a13036c077a8de74c02b7646d08012c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute smallest enclosing sphere of points <br /></td></tr>
<tr class="separator:a13036c077a8de74c02b7646d08012c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29647d32e032cc35e52b51591295ca60"><td class="memTemplParams" colspan="2"><a class="anchor" id="a29647d32e032cc35e52b51591295ca60"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a29647d32e032cc35e52b51591295ca60"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a29647d32e032cc35e52b51591295ca60">erf</a> (const T x)</td></tr>
<tr class="memdesc:a29647d32e032cc35e52b51591295ca60"><td class="mdescLeft">&#160;</td><td class="mdescRight">error function <br /></td></tr>
<tr class="separator:a29647d32e032cc35e52b51591295ca60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3c0f788a80d7dd395ab7585f94ab97"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0d3c0f788a80d7dd395ab7585f94ab97"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0d3c0f788a80d7dd395ab7585f94ab97"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a0d3c0f788a80d7dd395ab7585f94ab97">erfc</a> (const T x)</td></tr>
<tr class="memdesc:a0d3c0f788a80d7dd395ab7585f94ab97"><td class="mdescLeft">&#160;</td><td class="mdescRight">complementary error function <br /></td></tr>
<tr class="separator:a0d3c0f788a80d7dd395ab7585f94ab97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce1cee7f941d273e312febdc800adb6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4ce1cee7f941d273e312febdc800adb6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4ce1cee7f941d273e312febdc800adb6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a4ce1cee7f941d273e312febdc800adb6">erfcx</a> (const T x)</td></tr>
<tr class="memdesc:a4ce1cee7f941d273e312febdc800adb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">scaled complementary error function <br /></td></tr>
<tr class="separator:a4ce1cee7f941d273e312febdc800adb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6333ed98afd5457f68b69cd20e69be0"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad6333ed98afd5457f68b69cd20e69be0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad6333ed98afd5457f68b69cd20e69be0"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ad6333ed98afd5457f68b69cd20e69be0">erfc_inv</a> (const T p)</td></tr>
<tr class="memdesc:ad6333ed98afd5457f68b69cd20e69be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">inverse complementary error function <br /></td></tr>
<tr class="separator:ad6333ed98afd5457f68b69cd20e69be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94aee89324bc58017a87e0e4c91a36a7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a94aee89324bc58017a87e0e4c91a36a7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94aee89324bc58017a87e0e4c91a36a7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a94aee89324bc58017a87e0e4c91a36a7">erf_inv</a> (const T p)</td></tr>
<tr class="memdesc:a94aee89324bc58017a87e0e4c91a36a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">inverse error function <br /></td></tr>
<tr class="separator:a94aee89324bc58017a87e0e4c91a36a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab694baa8c568f3b1b8ce1bce8eff34d5"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab694baa8c568f3b1b8ce1bce8eff34d5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab694baa8c568f3b1b8ce1bce8eff34d5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ab694baa8c568f3b1b8ce1bce8eff34d5">norm_pdf</a> (const T x, const T mu=0, const T sig=1)</td></tr>
<tr class="memdesc:ab694baa8c568f3b1b8ce1bce8eff34d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">normal distribution prob density function <br /></td></tr>
<tr class="separator:ab694baa8c568f3b1b8ce1bce8eff34d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec476dd99fd70352b186271b3e26fce"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0ec476dd99fd70352b186271b3e26fce"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ec476dd99fd70352b186271b3e26fce"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a0ec476dd99fd70352b186271b3e26fce">norm_cdf</a> (const T x, const T mu=0, const T sig=1)</td></tr>
<tr class="memdesc:a0ec476dd99fd70352b186271b3e26fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">normal cumulative distribution function <br /></td></tr>
<tr class="separator:a0ec476dd99fd70352b186271b3e26fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6085e1cc9615134e20dd06f98c0b93"><td class="memTemplParams" colspan="2"><a class="anchor" id="aca6085e1cc9615134e20dd06f98c0b93"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca6085e1cc9615134e20dd06f98c0b93"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#aca6085e1cc9615134e20dd06f98c0b93">norm_inv</a> (const T &amp;p, const T mu=0, const T sig=1)</td></tr>
<tr class="memdesc:aca6085e1cc9615134e20dd06f98c0b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">inverse normal cumulative distribution function <br /></td></tr>
<tr class="separator:aca6085e1cc9615134e20dd06f98c0b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf88fb10568cfdc08badf9f1689cb9da"><td class="memTemplParams" colspan="2"><a class="anchor" id="abf88fb10568cfdc08badf9f1689cb9da"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abf88fb10568cfdc08badf9f1689cb9da"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#abf88fb10568cfdc08badf9f1689cb9da">logn_pdf</a> (const T x, const T mu=0, const T sig=1)</td></tr>
<tr class="memdesc:abf88fb10568cfdc08badf9f1689cb9da"><td class="mdescLeft">&#160;</td><td class="mdescRight">lognormal normal prob distribution function <br /></td></tr>
<tr class="separator:abf88fb10568cfdc08badf9f1689cb9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b474dd6ff829663a8a4d47453505b4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae7b474dd6ff829663a8a4d47453505b4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae7b474dd6ff829663a8a4d47453505b4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ae7b474dd6ff829663a8a4d47453505b4">logn_cdf</a> (const T x, const T mu=0, const T sig=1)</td></tr>
<tr class="memdesc:ae7b474dd6ff829663a8a4d47453505b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">log normal cumulative distribution function <br /></td></tr>
<tr class="separator:ae7b474dd6ff829663a8a4d47453505b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076f812d3f95cae1c4f4fa71084aeae5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a076f812d3f95cae1c4f4fa71084aeae5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a076f812d3f95cae1c4f4fa71084aeae5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a076f812d3f95cae1c4f4fa71084aeae5">logn_inv</a> (const T p, const T mu=0, const T sig=1)</td></tr>
<tr class="memdesc:a076f812d3f95cae1c4f4fa71084aeae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">inverse log normal cumulative distribution function <br /></td></tr>
<tr class="separator:a076f812d3f95cae1c4f4fa71084aeae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9478f2f6720791cffd14e8abdd7860d9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9478f2f6720791cffd14e8abdd7860d9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9478f2f6720791cffd14e8abdd7860d9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a9478f2f6720791cffd14e8abdd7860d9">uniform_pdf</a> (const T x, const T a, const T b)</td></tr>
<tr class="memdesc:a9478f2f6720791cffd14e8abdd7860d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">uniform distribution prob density function <br /></td></tr>
<tr class="separator:a9478f2f6720791cffd14e8abdd7860d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72681a74de04e7781633ccde28edd34f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a72681a74de04e7781633ccde28edd34f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a72681a74de04e7781633ccde28edd34f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a72681a74de04e7781633ccde28edd34f">uniform_cdf</a> (const T x, const T a, const T b)</td></tr>
<tr class="memdesc:a72681a74de04e7781633ccde28edd34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">uniform cumulative distribution function <br /></td></tr>
<tr class="separator:a72681a74de04e7781633ccde28edd34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb57efeef3c6f8caac9f2769628a623"><td class="memTemplParams" colspan="2"><a class="anchor" id="abfb57efeef3c6f8caac9f2769628a623"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abfb57efeef3c6f8caac9f2769628a623"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#abfb57efeef3c6f8caac9f2769628a623">ksc_cdf</a> (const T z)</td></tr>
<tr class="memdesc:abfb57efeef3c6f8caac9f2769628a623"><td class="mdescLeft">&#160;</td><td class="mdescRight">complementary cumulative kolmogorov-smirnov distribution function <br /></td></tr>
<tr class="separator:abfb57efeef3c6f8caac9f2769628a623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127fbe38e376c844bf6b64674149e358"><td class="memTemplParams" colspan="2"><a class="anchor" id="a127fbe38e376c844bf6b64674149e358"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a127fbe38e376c844bf6b64674149e358"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a127fbe38e376c844bf6b64674149e358">invxlogx</a> (const T y)</td></tr>
<tr class="memdesc:a127fbe38e376c844bf6b64674149e358"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to compute ksc_inv <br /></td></tr>
<tr class="separator:a127fbe38e376c844bf6b64674149e358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08886183ded948207b97a4a3c15f8adf"><td class="memTemplParams" colspan="2"><a class="anchor" id="a08886183ded948207b97a4a3c15f8adf"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a08886183ded948207b97a4a3c15f8adf"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a08886183ded948207b97a4a3c15f8adf">ksc_inv</a> (const T q)</td></tr>
<tr class="memdesc:a08886183ded948207b97a4a3c15f8adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">inverse complementary cumulative kolmogorv-smirnov distribution function <br /></td></tr>
<tr class="separator:a08886183ded948207b97a4a3c15f8adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadccc22955d27028af5e260dc236da3"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeadccc22955d27028af5e260dc236da3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeadccc22955d27028af5e260dc236da3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#aeadccc22955d27028af5e260dc236da3">ks_inv</a> (const T p)</td></tr>
<tr class="memdesc:aeadccc22955d27028af5e260dc236da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">inverse of the cumulative kolmogorv-smirnov distribution function <br /></td></tr>
<tr class="separator:aeadccc22955d27028af5e260dc236da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4dd7de30e965b53e1c482e2508acd6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8c4dd7de30e965b53e1c482e2508acd6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a8c4dd7de30e965b53e1c482e2508acd6">norm_ks_test</a> (const T mu, const T sig, <a class="el" href="a00127.html">vec</a>&lt; T &gt; data)</td></tr>
<tr class="separator:a8c4dd7de30e965b53e1c482e2508acd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5126d3fba41bcf13dea265548d9c21c1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5126d3fba41bcf13dea265548d9c21c1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a5126d3fba41bcf13dea265548d9c21c1">ks_test</a> (<a class="el" href="a00127.html">vec</a>&lt; T &gt; data1, <a class="el" href="a00127.html">vec</a>&lt; T &gt; data2)</td></tr>
<tr class="separator:a5126d3fba41bcf13dea265548d9c21c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a005510b7ffa2c6a772d826ba2c164"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab6a005510b7ffa2c6a772d826ba2c164"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ab6a005510b7ffa2c6a772d826ba2c164">svd</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;a, <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;u, <a class="el" href="a00106.html">diag_mat</a>&lt; T &gt; &amp;w, <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;v, bool ordering=true, int maxiter=30)</td></tr>
<tr class="separator:ab6a005510b7ffa2c6a772d826ba2c164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac466ec1d1ddb11e3baef1c3d7e93296f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac466ec1d1ddb11e3baef1c3d7e93296f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac466ec1d1ddb11e3baef1c3d7e93296f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ac466ec1d1ddb11e3baef1c3d7e93296f">null</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:ac466ec1d1ddb11e3baef1c3d7e93296f"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the null space of a matrix <br /></td></tr>
<tr class="separator:ac466ec1d1ddb11e3baef1c3d7e93296f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8801c55a874b826030c7e4fa60d26f59"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8801c55a874b826030c7e4fa60d26f59"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8801c55a874b826030c7e4fa60d26f59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a8801c55a874b826030c7e4fa60d26f59">null</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;a, T tol)</td></tr>
<tr class="memdesc:a8801c55a874b826030c7e4fa60d26f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the effective null space of a matrix using user defined tolerance <br /></td></tr>
<tr class="separator:a8801c55a874b826030c7e4fa60d26f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d19805e29525bb8e3450411eaf43f4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a15d19805e29525bb8e3450411eaf43f4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a15d19805e29525bb8e3450411eaf43f4"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a15d19805e29525bb8e3450411eaf43f4">rank</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:a15d19805e29525bb8e3450411eaf43f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the rank of a matrix using svd <br /></td></tr>
<tr class="separator:a15d19805e29525bb8e3450411eaf43f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fce4e1b725798d6fdd6f8ab2a0ea89"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad3fce4e1b725798d6fdd6f8ab2a0ea89"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad3fce4e1b725798d6fdd6f8ab2a0ea89"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ad3fce4e1b725798d6fdd6f8ab2a0ea89">rank</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;a, T tol)</td></tr>
<tr class="memdesc:ad3fce4e1b725798d6fdd6f8ab2a0ea89"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the effective rank of a matrix using svd and the given tolerance tol <br /></td></tr>
<tr class="separator:ad3fce4e1b725798d6fdd6f8ab2a0ea89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01f02edd8e30cf1e4341c07c7c3afae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac01f02edd8e30cf1e4341c07c7c3afae"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ac01f02edd8e30cf1e4341c07c7c3afae">solve_underdetermined_system</a> (const <a class="el" href="a00110.html">cgv::math::mat</a>&lt; T &gt; &amp;A, const <a class="el" href="a00127.html">cgv::math::vec</a>&lt; T &gt; &amp;b, <a class="el" href="a00127.html">cgv::math::vec</a>&lt; T &gt; &amp;p, <a class="el" href="a00110.html">cgv::math::mat</a>&lt; T &gt; &amp;N)</td></tr>
<tr class="separator:ac01f02edd8e30cf1e4341c07c7c3afae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d643dede4f904b08dc0f5eb1db7b287"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d643dede4f904b08dc0f5eb1db7b287"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a6d643dede4f904b08dc0f5eb1db7b287">find_nonrigid_transformation</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;points1, const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;points2, <a class="el" href="a00122.html">thin_plate_spline</a>&lt; T &gt; &amp;spline)</td></tr>
<tr class="separator:a6d643dede4f904b08dc0f5eb1db7b287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac970ad822a64c86702f1ec3ac21af1b6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac970ad822a64c86702f1ec3ac21af1b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ac970ad822a64c86702f1ec3ac21af1b6">find_nonrigid_transformation</a> (const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;points1, const <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;points2, <a class="el" href="a00121.html">thin_hyper_plate_spline</a>&lt; T &gt; &amp;spline)</td></tr>
<tr class="separator:ac970ad822a64c86702f1ec3ac21af1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9716f3d02a56270fbad9174562bec242"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9716f3d02a56270fbad9174562bec242"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a9716f3d02a56270fbad9174562bec242">apply_nonrigid_transformation</a> (const <a class="el" href="a00122.html">thin_plate_spline</a>&lt; T &gt; &amp;s, <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;points)</td></tr>
<tr class="separator:a9716f3d02a56270fbad9174562bec242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb844540e70f134515a6e5114f163da"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adfb844540e70f134515a6e5114f163da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#adfb844540e70f134515a6e5114f163da">apply_nonrigid_transformation</a> (const <a class="el" href="a00121.html">thin_hyper_plate_spline</a>&lt; T &gt; &amp;s, <a class="el" href="a00110.html">mat</a>&lt; T &gt; &amp;points)</td></tr>
<tr class="separator:adfb844540e70f134515a6e5114f163da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85897d2b217993a9a037e398cb5b3574"><td class="memTemplParams" colspan="2"><a class="anchor" id="a85897d2b217993a9a037e398cb5b3574"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a85897d2b217993a9a037e398cb5b3574"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a85897d2b217993a9a037e398cb5b3574">scale_33</a> (const T &amp;sx, const T &amp;sy, const T &amp;sz)</td></tr>
<tr class="memdesc:a85897d2b217993a9a037e398cb5b3574"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 3x3 scale matrix <br /></td></tr>
<tr class="separator:a85897d2b217993a9a037e398cb5b3574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac596cebb0e1bb3d7c3a3c6a7f09d40"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3ac596cebb0e1bb3d7c3a3c6a7f09d40"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ac596cebb0e1bb3d7c3a3c6a7f09d40"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a3ac596cebb0e1bb3d7c3a3c6a7f09d40">scale_33</a> (const T &amp;s)</td></tr>
<tr class="memdesc:a3ac596cebb0e1bb3d7c3a3c6a7f09d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 3x3 uniform scale matrix <br /></td></tr>
<tr class="separator:a3ac596cebb0e1bb3d7c3a3c6a7f09d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e0707a52e79e75a0cfc92fb9692440"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab0e0707a52e79e75a0cfc92fb9692440"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab0e0707a52e79e75a0cfc92fb9692440"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ab0e0707a52e79e75a0cfc92fb9692440">rotatex_33</a> (const T &amp;angle)</td></tr>
<tr class="memdesc:ab0e0707a52e79e75a0cfc92fb9692440"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 3x3 rotation matrix around the x axis, the angle is in degree <br /></td></tr>
<tr class="separator:ab0e0707a52e79e75a0cfc92fb9692440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086592be0c324c31e0288e3049575da9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a086592be0c324c31e0288e3049575da9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a086592be0c324c31e0288e3049575da9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a086592be0c324c31e0288e3049575da9">rotatey_33</a> (const T &amp;angle)</td></tr>
<tr class="memdesc:a086592be0c324c31e0288e3049575da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 3x3 rotation matrix around the y axis, the angle is in degree <br /></td></tr>
<tr class="separator:a086592be0c324c31e0288e3049575da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cc5ddf263bbdc7ae430b3fa059c363"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac0cc5ddf263bbdc7ae430b3fa059c363"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac0cc5ddf263bbdc7ae430b3fa059c363"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ac0cc5ddf263bbdc7ae430b3fa059c363">rotatez_33</a> (const T &amp;angle)</td></tr>
<tr class="memdesc:ac0cc5ddf263bbdc7ae430b3fa059c363"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 3x3 rotation matrix around the z axis, the angle is in degree <br /></td></tr>
<tr class="separator:ac0cc5ddf263bbdc7ae430b3fa059c363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b1dab60bc2f964bdb9aa6a3952bf88"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab3b1dab60bc2f964bdb9aa6a3952bf88"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab3b1dab60bc2f964bdb9aa6a3952bf88"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ab3b1dab60bc2f964bdb9aa6a3952bf88">rotate_22</a> (const T &amp;angle)</td></tr>
<tr class="memdesc:ab3b1dab60bc2f964bdb9aa6a3952bf88"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 2x2 rotation matrix around the z axis, the angle is in degree <br /></td></tr>
<tr class="separator:ab3b1dab60bc2f964bdb9aa6a3952bf88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be9e16273ef156049f7766118d2d1c2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7be9e16273ef156049f7766118d2d1c2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7be9e16273ef156049f7766118d2d1c2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a7be9e16273ef156049f7766118d2d1c2">rotate_euler_33</a> (const T &amp;yaw, const T &amp;pitch, const T &amp;roll)</td></tr>
<tr class="memdesc:a7be9e16273ef156049f7766118d2d1c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 3x3 euler rotation matrix from yaw, pitch and roll given in degree <br /></td></tr>
<tr class="separator:a7be9e16273ef156049f7766118d2d1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e87c4efe1ce93998b6e87a667dcf463"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0e87c4efe1ce93998b6e87a667dcf463"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e87c4efe1ce93998b6e87a667dcf463"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a0e87c4efe1ce93998b6e87a667dcf463">rotate_rodrigues_33</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;r)</td></tr>
<tr class="memdesc:a0e87c4efe1ce93998b6e87a667dcf463"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 3x3 rotation matrix from a rodrigues vector <br /></td></tr>
<tr class="separator:a0e87c4efe1ce93998b6e87a667dcf463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8880baf768a767a53dbf0261b356a8"><td class="memTemplParams" colspan="2"><a class="anchor" id="aee8880baf768a767a53dbf0261b356a8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aee8880baf768a767a53dbf0261b356a8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#aee8880baf768a767a53dbf0261b356a8">shearxy_33</a> (const T &amp;shx, const T &amp;shy)</td></tr>
<tr class="memdesc:aee8880baf768a767a53dbf0261b356a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a homogen 3x3 shear matrix with given shears shx in x direction, and shy in y direction <br /></td></tr>
<tr class="separator:aee8880baf768a767a53dbf0261b356a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dcd77ed27e7f6f1a6039a8d5b9aa7d2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9dcd77ed27e7f6f1a6039a8d5b9aa7d2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9dcd77ed27e7f6f1a6039a8d5b9aa7d2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a9dcd77ed27e7f6f1a6039a8d5b9aa7d2">shearxz_33</a> (const T &amp;shx, const T &amp;shz)</td></tr>
<tr class="memdesc:a9dcd77ed27e7f6f1a6039a8d5b9aa7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a homogen 3x3 shear matrix with given shears shx in x direction, and shy in y direction <br /></td></tr>
<tr class="separator:a9dcd77ed27e7f6f1a6039a8d5b9aa7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2d0dcf002caa9b75644e2e26485b84"><td class="memTemplParams" colspan="2"><a class="anchor" id="aed2d0dcf002caa9b75644e2e26485b84"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aed2d0dcf002caa9b75644e2e26485b84"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#aed2d0dcf002caa9b75644e2e26485b84">shearyz_33</a> (const T &amp;shy, const T &amp;shz)</td></tr>
<tr class="memdesc:aed2d0dcf002caa9b75644e2e26485b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a homogen 3x3 shear matrix with given shears shy in y direction, and shz in z direction <br /></td></tr>
<tr class="separator:aed2d0dcf002caa9b75644e2e26485b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dce7e66246f1276129c1e05e87ede77"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8dce7e66246f1276129c1e05e87ede77"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8dce7e66246f1276129c1e05e87ede77"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a8dce7e66246f1276129c1e05e87ede77">shear_33</a> (const T &amp;syx, const T &amp;szx, const T &amp;sxy, const T &amp;szy, const T &amp;sxz, const T &amp;syz)</td></tr>
<tr class="memdesc:a8dce7e66246f1276129c1e05e87ede77"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a homogen 3x3 shear matrix <br /></td></tr>
<tr class="separator:a8dce7e66246f1276129c1e05e87ede77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2334fc8abf0502a02e53c0fe3f50fe1"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae2334fc8abf0502a02e53c0fe3f50fe1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2334fc8abf0502a02e53c0fe3f50fe1"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ae2334fc8abf0502a02e53c0fe3f50fe1">translate_44</a> (const T &amp;x, const T &amp;y, const T &amp;z)</td></tr>
<tr class="memdesc:ae2334fc8abf0502a02e53c0fe3f50fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 4x4 translation matrix <br /></td></tr>
<tr class="separator:ae2334fc8abf0502a02e53c0fe3f50fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568b4d99cf097823e39290ab0de26e69"><td class="memTemplParams" colspan="2"><a class="anchor" id="a568b4d99cf097823e39290ab0de26e69"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a568b4d99cf097823e39290ab0de26e69"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a568b4d99cf097823e39290ab0de26e69">translate_44</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a568b4d99cf097823e39290ab0de26e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 4x4 translation matrix <br /></td></tr>
<tr class="separator:a568b4d99cf097823e39290ab0de26e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0bceb8808fb01a77d3470ed3fc5d88"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaa0bceb8808fb01a77d3470ed3fc5d88"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaa0bceb8808fb01a77d3470ed3fc5d88"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#aaa0bceb8808fb01a77d3470ed3fc5d88">scale_44</a> (const T &amp;sx, const T &amp;sy, const T &amp;sz)</td></tr>
<tr class="memdesc:aaa0bceb8808fb01a77d3470ed3fc5d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 4x4 scale matrix <br /></td></tr>
<tr class="separator:aaa0bceb8808fb01a77d3470ed3fc5d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d32bbb09e0fecd28e0c212b33c0646f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0d32bbb09e0fecd28e0c212b33c0646f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0d32bbb09e0fecd28e0c212b33c0646f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a0d32bbb09e0fecd28e0c212b33c0646f">scale_44</a> (const T &amp;s)</td></tr>
<tr class="memdesc:a0d32bbb09e0fecd28e0c212b33c0646f"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 4x4 uniform scale matrix <br /></td></tr>
<tr class="separator:a0d32bbb09e0fecd28e0c212b33c0646f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf10e12d3be0022b5a5b6ff7a4a3edc"><td class="memTemplParams" colspan="2"><a class="anchor" id="aabf10e12d3be0022b5a5b6ff7a4a3edc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aabf10e12d3be0022b5a5b6ff7a4a3edc"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#aabf10e12d3be0022b5a5b6ff7a4a3edc">rotatex_44</a> (const T &amp;angle)</td></tr>
<tr class="memdesc:aabf10e12d3be0022b5a5b6ff7a4a3edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 4x4 rotation matrix around the x axis, the angle is in degree <br /></td></tr>
<tr class="separator:aabf10e12d3be0022b5a5b6ff7a4a3edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af1012c37e89444fe07e1db7095ce48"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3af1012c37e89444fe07e1db7095ce48"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3af1012c37e89444fe07e1db7095ce48"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a3af1012c37e89444fe07e1db7095ce48">rotatey_44</a> (const T &amp;angle)</td></tr>
<tr class="memdesc:a3af1012c37e89444fe07e1db7095ce48"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 4x4 rotation matrix around the y axis, the angle is in degree <br /></td></tr>
<tr class="separator:a3af1012c37e89444fe07e1db7095ce48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae6299da0f3744cc6b530f51c605d3d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8ae6299da0f3744cc6b530f51c605d3d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8ae6299da0f3744cc6b530f51c605d3d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a8ae6299da0f3744cc6b530f51c605d3d">rotatez_44</a> (const T &amp;angle)</td></tr>
<tr class="memdesc:a8ae6299da0f3744cc6b530f51c605d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 4x4 rotation matrix around the z axis, the angle is in degree <br /></td></tr>
<tr class="separator:a8ae6299da0f3744cc6b530f51c605d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e1fe663d9b1c90559970dbc8a67a63"><td class="memTemplParams" colspan="2"><a class="anchor" id="a02e1fe663d9b1c90559970dbc8a67a63"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a02e1fe663d9b1c90559970dbc8a67a63"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a02e1fe663d9b1c90559970dbc8a67a63">rotate_euler_44</a> (const T &amp;yaw, const T &amp;pitch, const T &amp;roll)</td></tr>
<tr class="memdesc:a02e1fe663d9b1c90559970dbc8a67a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a 4x4 euler rotation matrix from yaw, pitch and roll given in degree <br /></td></tr>
<tr class="separator:a02e1fe663d9b1c90559970dbc8a67a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018df25110f4041d6785f92dbc4d62bb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a018df25110f4041d6785f92dbc4d62bb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a018df25110f4041d6785f92dbc4d62bb"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a018df25110f4041d6785f92dbc4d62bb">shearxy_44</a> (const T &amp;shx, const T &amp;shy)</td></tr>
<tr class="memdesc:a018df25110f4041d6785f92dbc4d62bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a homogen 4x4 shear matrix with given shears shx in x direction, and shy in y direction <br /></td></tr>
<tr class="separator:a018df25110f4041d6785f92dbc4d62bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27af5bc5a31543c397b23cf457bb1ded"><td class="memTemplParams" colspan="2"><a class="anchor" id="a27af5bc5a31543c397b23cf457bb1ded"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a27af5bc5a31543c397b23cf457bb1ded"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a27af5bc5a31543c397b23cf457bb1ded">shearxz_44</a> (const T &amp;shx, const T &amp;shz)</td></tr>
<tr class="memdesc:a27af5bc5a31543c397b23cf457bb1ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a homogen 4x4 shear matrix with given shears shx in x direction, and shy in y direction <br /></td></tr>
<tr class="separator:a27af5bc5a31543c397b23cf457bb1ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5acdd483aead1daa92d9817fb46c68"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5d5acdd483aead1daa92d9817fb46c68"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5d5acdd483aead1daa92d9817fb46c68"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a5d5acdd483aead1daa92d9817fb46c68">shearyz_44</a> (const T &amp;shy, const T &amp;shz)</td></tr>
<tr class="memdesc:a5d5acdd483aead1daa92d9817fb46c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a homogen 4x4 shear matrix with given shears shy in y direction, and shz in z direction <br /></td></tr>
<tr class="separator:a5d5acdd483aead1daa92d9817fb46c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f2a62ee6584cf62da2425dc7ee3d29"><td class="memTemplParams" colspan="2"><a class="anchor" id="a01f2a62ee6584cf62da2425dc7ee3d29"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a01f2a62ee6584cf62da2425dc7ee3d29"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a01f2a62ee6584cf62da2425dc7ee3d29">shear_44</a> (const T &amp;syx, const T &amp;szx, const T &amp;sxy, const T &amp;szy, const T &amp;sxz, const T &amp;syz)</td></tr>
<tr class="memdesc:a01f2a62ee6584cf62da2425dc7ee3d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a homogen 4x4 shear matrix <br /></td></tr>
<tr class="separator:a01f2a62ee6584cf62da2425dc7ee3d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba648b00ae542924b1b616fb3ebd1970"><td class="memTemplParams" colspan="2"><a class="anchor" id="aba648b00ae542924b1b616fb3ebd1970"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba648b00ae542924b1b616fb3ebd1970"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#aba648b00ae542924b1b616fb3ebd1970">perspective_44</a> (const T &amp;fovy, const T &amp;aspect, const T &amp;znear, const T &amp;zfar)</td></tr>
<tr class="memdesc:aba648b00ae542924b1b616fb3ebd1970"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a perspective transformation matrix in the same way as gluPerspective does <br /></td></tr>
<tr class="separator:aba648b00ae542924b1b616fb3ebd1970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a5d4054e3dd13ffa072bc48e71e4fa"><td class="memTemplParams" colspan="2"><a class="anchor" id="a38a5d4054e3dd13ffa072bc48e71e4fa"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a38a5d4054e3dd13ffa072bc48e71e4fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a38a5d4054e3dd13ffa072bc48e71e4fa">viewport_44</a> (const T &amp;xoff, const T yoff, const T &amp;width, const T &amp;height)</td></tr>
<tr class="memdesc:a38a5d4054e3dd13ffa072bc48e71e4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a viewport transformation matrix <br /></td></tr>
<tr class="separator:a38a5d4054e3dd13ffa072bc48e71e4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66aa3ebe8fea232a892cb4d573d7417"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa66aa3ebe8fea232a892cb4d573d7417"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa66aa3ebe8fea232a892cb4d573d7417"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#aa66aa3ebe8fea232a892cb4d573d7417">look_at_44</a> (const T &amp;eyex, const T &amp;eyey, const T &amp;eyez, const T &amp;centerx, const T &amp;centery, const T &amp;centerz, const T &amp;upx, const T &amp;upy, const T &amp;upz)</td></tr>
<tr class="memdesc:aa66aa3ebe8fea232a892cb4d573d7417"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a look at transformation matrix in the same way as gluLookAt does <br /></td></tr>
<tr class="separator:aa66aa3ebe8fea232a892cb4d573d7417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2863bde90a02f899c542ae1cc32050d6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2863bde90a02f899c542ae1cc32050d6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2863bde90a02f899c542ae1cc32050d6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a2863bde90a02f899c542ae1cc32050d6">frustrum_44</a> (const T &amp;left, const T &amp;right, const T &amp;bottom, const T &amp;top, const T &amp;znear, const T &amp;zfar)</td></tr>
<tr class="memdesc:a2863bde90a02f899c542ae1cc32050d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a frustrum projection matrix in the same way as glFrustum does <br /></td></tr>
<tr class="separator:a2863bde90a02f899c542ae1cc32050d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8f1728daa988d11083043934c019d6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6c8f1728daa988d11083043934c019d6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6c8f1728daa988d11083043934c019d6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a6c8f1728daa988d11083043934c019d6">ortho_44</a> (const T &amp;left, const T &amp;right, const T &amp;bottom, const T &amp;top, const T &amp;znear, const T &amp;zfar)</td></tr>
<tr class="memdesc:a6c8f1728daa988d11083043934c019d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates an orthographic projection matrix in the same way as glOrtho does <br /></td></tr>
<tr class="separator:a6c8f1728daa988d11083043934c019d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df8b010b858a0a2fd2913861084c5c2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0df8b010b858a0a2fd2913861084c5c2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0df8b010b858a0a2fd2913861084c5c2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a0df8b010b858a0a2fd2913861084c5c2">ortho2d_44</a> (const T &amp;left, const T &amp;right, const T &amp;bottom, const T &amp;top)</td></tr>
<tr class="memdesc:a0df8b010b858a0a2fd2913861084c5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates an orthographic projection matrix in the same way as glOrtho2d does <br /></td></tr>
<tr class="separator:a0df8b010b858a0a2fd2913861084c5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1b531c1e2ddf68b8739abb1d882231"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2c1b531c1e2ddf68b8739abb1d882231"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2c1b531c1e2ddf68b8739abb1d882231"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00110.html">mat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a2c1b531c1e2ddf68b8739abb1d882231">pick_44</a> (const T &amp;x, const T &amp;y, const T &amp;width, const T &amp;height, int viewport[4], const <a class="el" href="a00110.html">mat</a>&lt; double &gt; &amp;modelviewproj, bool flipy=true)</td></tr>
<tr class="memdesc:a2c1b531c1e2ddf68b8739abb1d882231"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a picking matrix like gluPickMatrix with pixel (0,0) in the lower left corner if flipy=false <br /></td></tr>
<tr class="separator:a2c1b531c1e2ddf68b8739abb1d882231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01d48e28fc77aefd5993faaa641e01a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad01d48e28fc77aefd5993faaa641e01a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad01d48e28fc77aefd5993faaa641e01a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ad01d48e28fc77aefd5993faaa641e01a">operator&lt;&lt;</a> (std::ostream &amp;out, const up_tri_mat&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:ad01d48e28fc77aefd5993faaa641e01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">output of a upper triangular matrix onto an ostream <br /></td></tr>
<tr class="separator:ad01d48e28fc77aefd5993faaa641e01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978d343e4d9cdf3c74249b3a9aefef15"><td class="memTemplParams" colspan="2"><a class="anchor" id="a978d343e4d9cdf3c74249b3a9aefef15"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a978d343e4d9cdf3c74249b3a9aefef15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a978d343e4d9cdf3c74249b3a9aefef15">normalize</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a978d343e4d9cdf3c74249b3a9aefef15"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a normalized version of v <br /></td></tr>
<tr class="separator:a978d343e4d9cdf3c74249b3a9aefef15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411bac494c2af0cff2a023a575ddeb2a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a411bac494c2af0cff2a023a575ddeb2a"></a>
template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a411bac494c2af0cff2a023a575ddeb2a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a411bac494c2af0cff2a023a575ddeb2a">p_norm</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;values, const S &amp;p=1)</td></tr>
<tr class="memdesc:a411bac494c2af0cff2a023a575ddeb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the p-norm of the vector default is p == 1 <br /></td></tr>
<tr class="separator:a411bac494c2af0cff2a023a575ddeb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d1188e252c04e6abccec35eed56d8f"><td class="memTemplParams" colspan="2"><a class="anchor" id="af8d1188e252c04e6abccec35eed56d8f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8d1188e252c04e6abccec35eed56d8f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#af8d1188e252c04e6abccec35eed56d8f">inf_norm</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:af8d1188e252c04e6abccec35eed56d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the infinity norm of the vector <br /></td></tr>
<tr class="separator:af8d1188e252c04e6abccec35eed56d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa61b101ea94ade16da7638005ec0401"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaa61b101ea94ade16da7638005ec0401"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaa61b101ea94ade16da7638005ec0401"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#aaa61b101ea94ade16da7638005ec0401">length</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:aaa61b101ea94ade16da7638005ec0401"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the length of v L2-norm <br /></td></tr>
<tr class="separator:aaa61b101ea94ade16da7638005ec0401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28f6653e67305af650b4403934a1c13"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab28f6653e67305af650b4403934a1c13"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab28f6653e67305af650b4403934a1c13"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ab28f6653e67305af650b4403934a1c13">sqr_length</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ab28f6653e67305af650b4403934a1c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the square length of v <br /></td></tr>
<tr class="separator:ab28f6653e67305af650b4403934a1c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1b0c1188a0d3f1778c36ec35a32168"><td class="memTemplParams" colspan="2"><a class="anchor" id="abc1b0c1188a0d3f1778c36ec35a32168"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abc1b0c1188a0d3f1778c36ec35a32168"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#abc1b0c1188a0d3f1778c36ec35a32168">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:abc1b0c1188a0d3f1778c36ec35a32168"><td class="mdescLeft">&#160;</td><td class="mdescRight">output of a vector <br /></td></tr>
<tr class="separator:abc1b0c1188a0d3f1778c36ec35a32168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ef485c2fbf3a9f9b9caed9aa4df0e1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a89ef485c2fbf3a9f9b9caed9aa4df0e1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a89ef485c2fbf3a9f9b9caed9aa4df0e1"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a89ef485c2fbf3a9f9b9caed9aa4df0e1">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a89ef485c2fbf3a9f9b9caed9aa4df0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">input of a vector <br /></td></tr>
<tr class="separator:a89ef485c2fbf3a9f9b9caed9aa4df0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0587d310c6306b8bde844d11bac48504"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0587d310c6306b8bde844d11bac48504"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0587d310c6306b8bde844d11bac48504"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a0587d310c6306b8bde844d11bac48504">operator*</a> (const T &amp;s, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a0587d310c6306b8bde844d11bac48504"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the product of a scalar s and vector v <br /></td></tr>
<tr class="separator:a0587d310c6306b8bde844d11bac48504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04bd0d69da4c57797eb232aca3b0d6b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad04bd0d69da4c57797eb232aca3b0d6b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad04bd0d69da4c57797eb232aca3b0d6b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ad04bd0d69da4c57797eb232aca3b0d6b">dot</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;w)</td></tr>
<tr class="memdesc:ad04bd0d69da4c57797eb232aca3b0d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the dot product of vector v and w <br /></td></tr>
<tr class="separator:ad04bd0d69da4c57797eb232aca3b0d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a44bdf6929252f47d50baac7da1425"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae9a44bdf6929252f47d50baac7da1425"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae9a44bdf6929252f47d50baac7da1425"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ae9a44bdf6929252f47d50baac7da1425">cross</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;w)</td></tr>
<tr class="memdesc:ae9a44bdf6929252f47d50baac7da1425"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the cross product of vector v and w <br /></td></tr>
<tr class="separator:ae9a44bdf6929252f47d50baac7da1425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0b909a09ab10500fd3683689258851"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2b0b909a09ab10500fd3683689258851"></a>
template&lt;typename T , typename S , typename U &gt; </td></tr>
<tr class="memitem:a2b0b909a09ab10500fd3683689258851"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a2b0b909a09ab10500fd3683689258851">dbl_cross</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;a, const <a class="el" href="a00127.html">vec</a>&lt; S &gt; &amp;b, <a class="el" href="a00127.html">vec</a>&lt; U &gt; &amp;c)</td></tr>
<tr class="memdesc:a2b0b909a09ab10500fd3683689258851"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the double cross product of vector a, b and c a x(b x c) <br /></td></tr>
<tr class="separator:a2b0b909a09ab10500fd3683689258851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a062bc927d2831ed28939db3703480"><td class="memTemplParams" colspan="2"><a class="anchor" id="a69a062bc927d2831ed28939db3703480"></a>
template&lt;typename T , typename S , typename U &gt; </td></tr>
<tr class="memitem:a69a062bc927d2831ed28939db3703480"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a69a062bc927d2831ed28939db3703480">spat</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;a, const <a class="el" href="a00127.html">vec</a>&lt; S &gt; &amp;b, const <a class="el" href="a00127.html">vec</a>&lt; U &gt; &amp;c)</td></tr>
<tr class="memdesc:a69a062bc927d2831ed28939db3703480"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the spat product (mixed vector product) of the vectors a, b and c <br /></td></tr>
<tr class="separator:a69a062bc927d2831ed28939db3703480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f1b79975130902277a2c38eb2ad56b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a92f1b79975130902277a2c38eb2ad56b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a92f1b79975130902277a2c38eb2ad56b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a92f1b79975130902277a2c38eb2ad56b">project</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;n)</td></tr>
<tr class="memdesc:a92f1b79975130902277a2c38eb2ad56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the projection of v onto n <br /></td></tr>
<tr class="separator:a92f1b79975130902277a2c38eb2ad56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5be51992b338933231c56f5b235e3e"><td class="memTemplParams" colspan="2"><a class="anchor" id="afa5be51992b338933231c56f5b235e3e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afa5be51992b338933231c56f5b235e3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#afa5be51992b338933231c56f5b235e3e">reflect</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;n)</td></tr>
<tr class="memdesc:afa5be51992b338933231c56f5b235e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the reflected direction of v; n is the normal of the reflecting surface <br /></td></tr>
<tr class="separator:afa5be51992b338933231c56f5b235e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b97afa2f0ea55aa60e8e2bbb16da022"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7b97afa2f0ea55aa60e8e2bbb16da022"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a7b97afa2f0ea55aa60e8e2bbb16da022">refract</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;n, T c1, T c2, bool *total_reflection=NULL)</td></tr>
<tr class="separator:a7b97afa2f0ea55aa60e8e2bbb16da022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769b0239ad7921d1debc13210eed9f1d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a769b0239ad7921d1debc13210eed9f1d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a769b0239ad7921d1debc13210eed9f1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a769b0239ad7921d1debc13210eed9f1d">zeros</a> (const unsigned dim)</td></tr>
<tr class="memdesc:a769b0239ad7921d1debc13210eed9f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a zero vector <br /></td></tr>
<tr class="separator:a769b0239ad7921d1debc13210eed9f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9867b26ce794ca923d333cfaddcc5a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0b9867b26ce794ca923d333cfaddcc5a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b9867b26ce794ca923d333cfaddcc5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a0b9867b26ce794ca923d333cfaddcc5a">ones</a> (const unsigned dim)</td></tr>
<tr class="memdesc:a0b9867b26ce794ca923d333cfaddcc5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a one vector <br /></td></tr>
<tr class="separator:a0b9867b26ce794ca923d333cfaddcc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fdbe5f90df73b06330b40a7183aeb5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a51fdbe5f90df73b06330b40a7183aeb5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51fdbe5f90df73b06330b40a7183aeb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a51fdbe5f90df73b06330b40a7183aeb5">floor</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a51fdbe5f90df73b06330b40a7183aeb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of componentwise floor values <br /></td></tr>
<tr class="separator:a51fdbe5f90df73b06330b40a7183aeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafe8353045ba1bc1dd078cedb40ab4b"><td class="memTemplParams" colspan="2"><a class="anchor" id="afafe8353045ba1bc1dd078cedb40ab4b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afafe8353045ba1bc1dd078cedb40ab4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#afafe8353045ba1bc1dd078cedb40ab4b">ceil</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:afafe8353045ba1bc1dd078cedb40ab4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of componentwise ceil values <br /></td></tr>
<tr class="separator:afafe8353045ba1bc1dd078cedb40ab4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944f7ad3594fbba4d34b9cef164f5943"><td class="memTemplParams" colspan="2"><a class="anchor" id="a944f7ad3594fbba4d34b9cef164f5943"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a944f7ad3594fbba4d34b9cef164f5943"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a944f7ad3594fbba4d34b9cef164f5943">round</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a944f7ad3594fbba4d34b9cef164f5943"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of componentwise ceil values <br /></td></tr>
<tr class="separator:a944f7ad3594fbba4d34b9cef164f5943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80001be79832e6abc3a7aa6493b3ea93"><td class="memTemplParams" colspan="2"><a class="anchor" id="a80001be79832e6abc3a7aa6493b3ea93"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a80001be79832e6abc3a7aa6493b3ea93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a80001be79832e6abc3a7aa6493b3ea93">abs</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a80001be79832e6abc3a7aa6493b3ea93"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of componentwise absolute values <br /></td></tr>
<tr class="separator:a80001be79832e6abc3a7aa6493b3ea93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c1c814d97961c2e09941d1b139d050"><td class="memTemplParams" colspan="2"><a class="anchor" id="a20c1c814d97961c2e09941d1b139d050"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a20c1c814d97961c2e09941d1b139d050"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a20c1c814d97961c2e09941d1b139d050">min_value</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a20c1c814d97961c2e09941d1b139d050"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the minimal entry <br /></td></tr>
<tr class="separator:a20c1c814d97961c2e09941d1b139d050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad026e67ce49ceabab907db2eb48d418"><td class="memTemplParams" colspan="2"><a class="anchor" id="aad026e67ce49ceabab907db2eb48d418"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aad026e67ce49ceabab907db2eb48d418"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#aad026e67ce49ceabab907db2eb48d418">min_index</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:aad026e67ce49ceabab907db2eb48d418"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the index of the smallest value <br /></td></tr>
<tr class="separator:aad026e67ce49ceabab907db2eb48d418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b30264dcb43c9e0fc553384e2568a2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad6b30264dcb43c9e0fc553384e2568a2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad6b30264dcb43c9e0fc553384e2568a2"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ad6b30264dcb43c9e0fc553384e2568a2">max_index</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ad6b30264dcb43c9e0fc553384e2568a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the index of the largest entry <br /></td></tr>
<tr class="separator:ad6b30264dcb43c9e0fc553384e2568a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711536231cafdd24b89b94059ba6ec46"><td class="memTemplParams" colspan="2"><a class="anchor" id="a711536231cafdd24b89b94059ba6ec46"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a711536231cafdd24b89b94059ba6ec46"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a711536231cafdd24b89b94059ba6ec46">max_value</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a711536231cafdd24b89b94059ba6ec46"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the value of the largest entry <br /></td></tr>
<tr class="separator:a711536231cafdd24b89b94059ba6ec46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe46549a352cc0c03a921e1a54531b1"><td class="memTemplParams" colspan="2"><a class="anchor" id="abbe46549a352cc0c03a921e1a54531b1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abbe46549a352cc0c03a921e1a54531b1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#abbe46549a352cc0c03a921e1a54531b1">mean_value</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:abbe46549a352cc0c03a921e1a54531b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the mean of all values <br /></td></tr>
<tr class="separator:abbe46549a352cc0c03a921e1a54531b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c378b0c8a7b79005500080d18dfdf0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59c378b0c8a7b79005500080d18dfdf0"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a59c378b0c8a7b79005500080d18dfdf0">var_value</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;values)</td></tr>
<tr class="separator:a59c378b0c8a7b79005500080d18dfdf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b51b9b6a031832d8f5e61daae591d23"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3b51b9b6a031832d8f5e61daae591d23"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b51b9b6a031832d8f5e61daae591d23"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a3b51b9b6a031832d8f5e61daae591d23">range_value</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:a3b51b9b6a031832d8f5e61daae591d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the range of all values <br /></td></tr>
<tr class="separator:a3b51b9b6a031832d8f5e61daae591d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d78d215cba9ac902cf783e07cacba82"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1d78d215cba9ac902cf783e07cacba82"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1d78d215cba9ac902cf783e07cacba82"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a1d78d215cba9ac902cf783e07cacba82">mad_value</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:a1d78d215cba9ac902cf783e07cacba82"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the median absolut deviation MAD <br /></td></tr>
<tr class="separator:a1d78d215cba9ac902cf783e07cacba82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcaec03b9e45ded6d1f1e9eadfdffac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5fcaec03b9e45ded6d1f1e9eadfdffac"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a5fcaec03b9e45ded6d1f1e9eadfdffac">std_value</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;values)</td></tr>
<tr class="separator:a5fcaec03b9e45ded6d1f1e9eadfdffac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a8c243810ff53fe2dba27b052ae806"><td class="memTemplParams" colspan="2"><a class="anchor" id="a10a8c243810ff53fe2dba27b052ae806"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a10a8c243810ff53fe2dba27b052ae806"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a10a8c243810ff53fe2dba27b052ae806">var_and_mean_value</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;values, T &amp;mu, T &amp;var)</td></tr>
<tr class="memdesc:a10a8c243810ff53fe2dba27b052ae806"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the mean and the variance (sigma^2) of all values <br /></td></tr>
<tr class="separator:a10a8c243810ff53fe2dba27b052ae806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52846938f1183bd690188020682e84b"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa52846938f1183bd690188020682e84b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa52846938f1183bd690188020682e84b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#aa52846938f1183bd690188020682e84b">sort_values</a> (<a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;values, bool ascending=true)</td></tr>
<tr class="memdesc:aa52846938f1183bd690188020682e84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">sort vector elements in ascending or descending order <br /></td></tr>
<tr class="separator:aa52846938f1183bd690188020682e84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ebc3f83af00eb06620f61e7e3e06e4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a68ebc3f83af00eb06620f61e7e3e06e4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a68ebc3f83af00eb06620f61e7e3e06e4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a68ebc3f83af00eb06620f61e7e3e06e4">sum_values</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:a68ebc3f83af00eb06620f61e7e3e06e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the sum of all entries <br /></td></tr>
<tr class="separator:a68ebc3f83af00eb06620f61e7e3e06e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb1cc83fc48654f1d5bd9982e1db1e2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7fb1cc83fc48654f1d5bd9982e1db1e2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a7fb1cc83fc48654f1d5bd9982e1db1e2">cumsum_values</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;values, <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;cumsumvalues)</td></tr>
<tr class="separator:a7fb1cc83fc48654f1d5bd9982e1db1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1a24be3eae3ff595cecbaa3a4f4ad3"><td class="memTemplParams" colspan="2"><a class="anchor" id="adf1a24be3eae3ff595cecbaa3a4f4ad3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adf1a24be3eae3ff595cecbaa3a4f4ad3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#adf1a24be3eae3ff595cecbaa3a4f4ad3">prod_values</a> (<a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:adf1a24be3eae3ff595cecbaa3a4f4ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the product of all entries <br /></td></tr>
<tr class="separator:adf1a24be3eae3ff595cecbaa3a4f4ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9115b6999049fb851dc6da02c0ca31"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0d9115b6999049fb851dc6da02c0ca31"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a0d9115b6999049fb851dc6da02c0ca31">select_value</a> (unsigned k, <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;values)</td></tr>
<tr class="separator:a0d9115b6999049fb851dc6da02c0ca31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10dff5b4a5e3e3f3727272dc9b129be5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a10dff5b4a5e3e3f3727272dc9b129be5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a10dff5b4a5e3e3f3727272dc9b129be5">select_median_value</a> (<a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;values)</td></tr>
<tr class="separator:a10dff5b4a5e3e3f3727272dc9b129be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64f0dd9dca92bc57478fd01ec0abf57"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab64f0dd9dca92bc57478fd01ec0abf57"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab64f0dd9dca92bc57478fd01ec0abf57"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ab64f0dd9dca92bc57478fd01ec0abf57">median_value</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:ab64f0dd9dca92bc57478fd01ec0abf57"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns median element without modifying the given vector <br /></td></tr>
<tr class="separator:ab64f0dd9dca92bc57478fd01ec0abf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d770ccb1369c369afc7f1f5b01c2c1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a62d770ccb1369c369afc7f1f5b01c2c1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a62d770ccb1369c369afc7f1f5b01c2c1"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a62d770ccb1369c369afc7f1f5b01c2c1">lin_space</a> (const T &amp;first_val, const T &amp;last_val, unsigned N=10)</td></tr>
<tr class="memdesc:a62d770ccb1369c369afc7f1f5b01c2c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a linearly spaced vector with N values starting at first_val and ending ant last_val <br /></td></tr>
<tr class="separator:a62d770ccb1369c369afc7f1f5b01c2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33cb46398dd66cb74e2355ce3d2373f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab33cb46398dd66cb74e2355ce3d2373f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ab33cb46398dd66cb74e2355ce3d2373f">log_space</a> (const T &amp;first_pow_of_10, const T &amp;last_pow_of_10, unsigned N=10)</td></tr>
<tr class="separator:ab33cb46398dd66cb74e2355ce3d2373f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1bd16fe490d8607e7b1051795cd9ad4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae1bd16fe490d8607e7b1051795cd9ad4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae1bd16fe490d8607e7b1051795cd9ad4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#ae1bd16fe490d8607e7b1051795cd9ad4">lerp</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v1, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v2, T t)</td></tr>
<tr class="memdesc:ae1bd16fe490d8607e7b1051795cd9ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear interpolation returns (1-t)*v1 + t*v2 <br /></td></tr>
<tr class="separator:ae1bd16fe490d8607e7b1051795cd9ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8024d9363f76baf24254130682ec21"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3c8024d9363f76baf24254130682ec21"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3c8024d9363f76baf24254130682ec21"><td class="memTemplItemLeft" align="right" valign="top">const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a3c8024d9363f76baf24254130682ec21">lerp</a> (const T &amp;s1, const T &amp;s2, T t)</td></tr>
<tr class="memdesc:a3c8024d9363f76baf24254130682ec21"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear interpolation returns (1-t)*v1 + t*v2 <br /></td></tr>
<tr class="separator:a3c8024d9363f76baf24254130682ec21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106cc64d2bdc02a0c169d79901eea313"><td class="memTemplParams" colspan="2"><a class="anchor" id="a106cc64d2bdc02a0c169d79901eea313"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a106cc64d2bdc02a0c169d79901eea313"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00127.html">vec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00711.html#a106cc64d2bdc02a0c169d79901eea313">slerp</a> (const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v0, const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;v1, T t)</td></tr>
<tr class="memdesc:a106cc64d2bdc02a0c169d79901eea313"><td class="mdescLeft">&#160;</td><td class="mdescRight">spherical linear interpolation <br /></td></tr>
<tr class="separator:a106cc64d2bdc02a0c169d79901eea313"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>namespace with classes and algorithms for mathematics </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a412054fabb1f60c7076fb8f714dbe77b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::AIC </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Akaike's: An Information Criterion k...number of parameters L...maximized value of likelihood function for estimated model n/k should be &gt; 40 otherwise use AICc (n ... number of samples) </p>

</div>
</div>
<a class="anchor" id="a7c949211e1bdcfb28758a678bdf06b5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::AIC_ls </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>RSS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Akaike's: An information criterion for k...number of parameters n...number of samples RSS...the residual sum of squares n/k should be greater 40 otherwise use AICc </p>

</div>
</div>
<a class="anchor" id="aa3c70cac0aed64ef9cb752790c0c1a23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::AICc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Akaike's: An information criterion with second order correction term k...number of parameters n.. number of samples L...maximized value of likelihood function for estimated model </p>

</div>
</div>
<a class="anchor" id="ab93ba61da7f07c4a49a79060d92a28ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::AICc_ls </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>RSS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Akaike's: An information criterion k...number of parameters n...number of samples RSS...the residual sum of squares </p>

</div>
</div>
<a class="anchor" id="aae5ea1af956e9651fccbedf5419f7adf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::AICu_ls </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>RSS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Akaike's: An information criterion k...number of parameters n...number of samples RSS...the residual sum of squares from the estimated model </p>

</div>
</div>
<a class="anchor" id="a9716f3d02a56270fbad9174562bec242"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cgv::math::apply_nonrigid_transformation </td>
          <td>(</td>
          <td class="paramtype">const thin_plate_spline&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>apply thin-plate-spline deformation in-place (without producing a copy of the points). This method should be used if a large number of points have to be deformed </p>

</div>
</div>
<a class="anchor" id="adfb844540e70f134515a6e5114f163da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cgv::math::apply_nonrigid_transformation </td>
          <td>(</td>
          <td class="paramtype">const thin_hyper_plate_spline&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>apply thin-hyper-plate-spline deformation in-place (without producing a copy of the points). This method should be used if a large number of points have to be deformed </p>

</div>
</div>
<a class="anchor" id="a2f884462214d37af98d55984170fb1c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cgv::math::Atx </td>
          <td>(</td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>atx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>multiply A^T*x A is a matrix and x is a vector </p>

</div>
</div>
<a class="anchor" id="aef5c2da55ba6e9caaac77a70bec26e92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::BIC </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bayesian information criterion (Schwarz Information Criterion) k...number of parameters n...number of samples </p>

</div>
</div>
<a class="anchor" id="ace4d7e7d0b479a4fcf81fd38af9fda4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::BIC_ls </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>RSS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bayesian information criterion (Schwarz Information Criterion) k...number of parameters n...number of samples RSS...the residual sum of squares from the estimated model </p>

</div>
</div>
<a class="anchor" id="a334232cf858e03e53db9bbf416fc76e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::bipoly_val </td>
          <td>(</td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>bivariate polynomials are stored in matrices in the following order: [a,b,c,d a*x1^3*x2^3 + b*x1^2*x2^3 + c*x1*x2^3 + d*x2^3 + e,f,g,h e*x1^3*x2^2 + f*x1^2*x2^2 + g*x1*x2^2 + h*x2^2 + i,j,k,l i*x1^3*x2 + j*x1^2*x2 + k*x1*x2 + l*x2 + m,n,o,p] m*x1^3 + n*x1^2 + o*x1 + p evaluate a bivariate polynomial p at (x1,x2) p is the coefficients matrix of the bivariate polynomial evaluation is done by using the horner scheme </p>

</div>
</div>
<a class="anchor" id="a71c3df147faeb70898d5d8be36ee6989"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::bipoly_val </td>
          <td>(</td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>evaluate a bivariate polynomial p at 2d position x p is the coefficients matrix of the bivariate polynomial evaluation is done by using the horner scheme </p>

</div>
</div>
<a class="anchor" id="a2b594665950a0417ea397d6d419fe826"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00110.html">mat</a>&lt;T&gt; cgv::math::create_color_map </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>steps</em> = <code>256</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;jet&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>creates different type of color map matrices colors are stored as columns in the resulting matrix the number of columns is defined by the parameter steps colormaps can be chosen by name : possible colormaps are "gray" black .. white "bone" grayscale colormap with a higher blue component (looks like xray images) "jet" blue .. cyan .. yellow .. orange .. red "hot" black .. red .. yellow .. white "thermo" black .. magenta .. blue.. cyan..green .. yellow ..red.. white "hsv" red .. yellow .. green .. cyan .. blue .. magenta .. red </p>

</div>
</div>
<a class="anchor" id="a7fb1cc83fc48654f1d5bd9982e1db1e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::cumsum_values </td>
          <td>(</td>
          <td class="paramtype">const vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cumsumvalues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>computes cumulative sums in cumsumvalues cumsumvalues[i] = values[0]+...+values[i-1] returns the sum of all entries </p>

</div>
</div>
<a class="anchor" id="ad13d980b9726467aeb59b55256fedda0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::math::decompose_rotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00110.html">cgv::math::mat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00127.html">cgv::math::vec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>extract axis and angle from rotation matrix returns true if successful problematic cases are angle == 0 and angle == 180 </p>

</div>
</div>
<a class="anchor" id="a7edcbce1ad75f9e7f698dfe11e8f41f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::math::eig_sym </td>
          <td>(</td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">diag_mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ordering</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>50</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>eigen decomposition of a symmetric matrix using the jacobi method v contains the eigenvectors d contains the eigenvalues a=v*d*transpose(v) </p>

</div>
</div>
<a class="anchor" id="a72df463c830e9334b8903566afb95fb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGV_API void cgv::math::estimate_normal_ls </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nr_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_evals</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_mean</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_evecs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute least squares normal from an array of 3D points. </p>
<p>Input is the number of points <code>nr_points</code> and a pointer <code>_points</code> to the point array. Points are assumed to be float tripples laying consecutively in the memory. Thus a vector <code>P</code> of type <code>std::vector&lt;cgv::math::fvec&lt;float,3&gt;</code> &gt; can be passed to this function according to estimate_normal_ls(P.size(), &amp;P.front()[0], ...). The resulting 3D normal is written into the memory point to by <code>_normal</code> assuming space for 3 floats. If <code>_evals</code> is specified, also the eigenvalues from the fit are written to 3 floats pointed to by <code>_evals</code>. If <code>_mean</code> is specified, also the point mean through which the least squares plane goes is returned. If <code>_evecs</code> is specified, also the eigenvectors from the fit are written in 3 float trippels to memory pointed to by <code>_evecs</code>. </p>

</div>
</div>
<a class="anchor" id="a6d643dede4f904b08dc0f5eb1db7b287"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cgv::math::find_nonrigid_transformation </td>
          <td>(</td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>points1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>points2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thin_plate_spline&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>spline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>fit thin plate spline to interpolate point correspondences suc that for columns i spline.map_position(points1.col(i)) == points2.col(i) points1 and points2 must contain at least 3 2d point correspondences </p>

</div>
</div>
<a class="anchor" id="ac970ad822a64c86702f1ec3ac21af1b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cgv::math::find_nonrigid_transformation </td>
          <td>(</td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>points1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>points2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thin_hyper_plate_spline&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>spline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>fit thin hyperplate spline to interpolate point correspondences such that for columns i spline.map_position(points1.col(i)) == points2.col(i) points1 and points2 must contain at least 4 3d point correspondences </p>

</div>
</div>
<a class="anchor" id="ab20031ad94f8b2a051428afe3a8ba59d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::math::gaussj </td>
          <td>(</td>
          <td class="paramtype">mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gauss-Jordan elimination (A*X=B) with full pivoting: The input matrix a is replaced by its inverse and the right hand side matrix b is replaced by ist corresponding solution matrix x. Returns false if the matrix is singular. </p>

</div>
</div>
<a class="anchor" id="afc42005ee85cb4bf30107636abfe7d6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::math::gaussj </td>
          <td>(</td>
          <td class="paramtype">mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>inverts a matrix a using gauss jordan elimination returns false if a is singular a is replaced with its inverse </p>

</div>
</div>
<a class="anchor" id="ab47423e8f43fdf220cc4baea42c5360c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">cgv::math::vec</a>&lt;T&gt; cgv::math::geometric_median </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00110.html">cgv::math::mat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0.0001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the geometric median of a set of points </p>

</div>
</div>
<a class="anchor" id="a5126d3fba41bcf13dea265548d9c21c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::ks_test </td>
          <td>(</td>
          <td class="paramtype">vec&lt; T &gt;&#160;</td>
          <td class="paramname"><em>data1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec&lt; T &gt;&#160;</td>
          <td class="paramname"><em>data2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>kolmogorov-smirnov test for comparing two sampled distributions returns the p-value for the null hypothesis that the the samples data1 are drawn from the same distribution as the samples of data2 </p>

</div>
</div>
<a class="anchor" id="ab33cb46398dd66cb74e2355ce3d2373f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00127.html">vec</a>&lt;T&gt; cgv::math::log_space </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>first_pow_of_10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>last_pow_of_10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>N</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>create a log spaced vector with N values starting at 10^first_pow_of_10 and ending at 10 last_val </p>

</div>
</div>
<a class="anchor" id="abbb40b8cf269e19d2dd02c8e5d7f2605"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::math::lu </td>
          <td>(</td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">perm_mat &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">low_tri_mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">up_tri_mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(P)LU decomposition of a matrix returns false if matrix is singular otherwise a = p*l*u </p>

</div>
</div>
<a class="anchor" id="a51224bf488aae401d2056c703e4ac56a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::math::lu_solve </td>
          <td>(</td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>solve ax=b with lu decomposition a is a full storage matrix </p>

</div>
</div>
<a class="anchor" id="a667e247eda3efd7411015db02d15a111"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::math::lu_solve </td>
          <td>(</td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>solves multiple linear systems ax=b a is full storage matrix x is the matrix of solution vectors (columns) b is the matrix of right-hand sides (columns) </p>

</div>
</div>
<a class="anchor" id="a8c4dd7de30e965b53e1c482e2508acd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::norm_ks_test </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec&lt; T &gt;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>kolmogorov-smirnov test for comparing samples with given normal distribution returns the p-value for the null hypothesis that the data is drawn from a normal distribution defined by mu and sigma </p>

</div>
</div>
<a class="anchor" id="a272db28d4d7d4cc2f6e608c50918a664"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned cgv::math::num_ransac_iterations </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>p_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>p_surety</em> = <code>0.99</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the number of needed ransac iterations n_min... minimal number of needed samples p_out... percentage of inliers p_surety... probability to sample at least one inlier </p>

</div>
</div>
<a class="anchor" id="a6fa33183d42422e47e25d8c55bbc9faa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::plane_val </td>
          <td>(</td>
          <td class="paramtype">const vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A plane is defined as a vector (a,b,c,d) =&gt; a*x1 + b*x2 +c*x3 +d = 0evaluate implicit plane equation at x =(x1,x2,x3) return value should be zero on plane </p>

</div>
</div>
<a class="anchor" id="a227ca8bca8d01aa6cad1f74c79994f2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cgv::math::polar </td>
          <td>(</td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_iter</em> = <code>15</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>polar decomposition of matrix c=r*a r orthonormal matrix a positive semi-definite matrix </p>

</div>
</div>
<a class="anchor" id="a9edb1c4b430e362c3cf62aae108746b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::math::poly_div </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>polynomial division f(x)/g(x) = q(x) + r(x)/g(x) returns true if r(x)=0 (rest 0) </p>

</div>
</div>
<a class="anchor" id="a9f72457452fa12679ad840de7b06df1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::poly_val </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>polynomials are stored in vectors in the following order: [a,b,c,d] ...a*x^3 + b*x^2 + c*x + d evaluate a polynomial p at x p is the vector of length n+1 whose elements are the coefficients of the polynomial in descending powers. evaluation is done by using the horner scheme </p>

</div>
</div>
<a class="anchor" id="a556f6aef31de955ddca54cf92650b5f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">vec</a>&lt;T&gt; cgv::math::poly_val </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00127.html">vec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>evaluate a polynomial p at multiple positions x p is the vector of length n+1 whose elements are the coefficients of the polynomial in descending powers. evaluation is done by using the horner scheme </p>

</div>
</div>
<a class="anchor" id="a39153e84c1ba0d7cd907ea31a1897f0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::math::qr_solve </td>
          <td>(</td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>solves multiple linear systems ax=b with qr solver a is full storage matrix x is the matrix of solution vectors (columns) b is the matrix of right-hand sides (columns) </p>

</div>
</div>
<a class="anchor" id="ac80c8817a7542063b7bb3bc47860ede6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">vec</a>&lt;T&gt; cgv::math::quat_multiply </td>
          <td>(</td>
          <td class="paramtype">const vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Quaterions are stored in vectors in the following order: [w, x, y, z] -&gt; w + x*i + y*j + z*k </p>

</div>
</div>
<a class="anchor" id="a980c68f5c243fa1a32c157ff23041952"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">vec</a>&lt;T&gt; cgv::math::ransac_plane_fit </td>
          <td>(</td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>p_out</em> = <code>0.8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>d_max</em> = <code>0.001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>p_surety</em> = <code>0.99</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>msac</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ransac plane fit p_out... outlier prob d_max... threshold distance p_surety... surety to compute number needed samples if m_sac flag is true m-estimator cost function is used if loransac flag is true </p>

</div>
</div>
<a class="anchor" id="a7b97afa2f0ea55aa60e8e2bbb16da022"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">vec</a>&lt;T&gt; cgv::math::refract </td>
          <td>(</td>
          <td class="paramtype">const vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>total_reflection</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>calculates the refracted direction of v on a surface with normal n and refraction indices c1,c2, *the optional parameter total reflection will be set true if a total reflection occured otherwise false </p>

</div>
</div>
<a class="anchor" id="a10dff5b4a5e3e3f3727272dc9b129be5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::select_median_value </td>
          <td>(</td>
          <td class="paramtype">vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the value of values the input vector arr will be rearanged to have this value in location arr[k], with all smaller elements moved to values[0..k-1] (in arbitrary order) and all larger elements in values[k+1..n] (also in arbitrary order). if the number of components are even then the ceil((n+1)/2) entry is returned </p>

</div>
</div>
<a class="anchor" id="a0d9115b6999049fb851dc6da02c0ca31"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::select_value </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the kth-smallest value of values the input vector values will be rearranged to have this value in location arr[k], with all smaller elements moved to values[0..k-1] (in arbitrary order) and all larger elements in values[k+1..n] (also in arbitrary order). </p>

</div>
</div>
<a class="anchor" id="a627d83610f33d7bbff7d122e789aef12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::math::solve </td>
          <td>(</td>
          <td class="paramtype">const up_tri_mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>solves linear system ax=b a is an upper triangular matrix </p>

</div>
</div>
<a class="anchor" id="a0bda1596ebd16a5de9f634a723a7f9df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::math::solve </td>
          <td>(</td>
          <td class="paramtype">const up_tri_mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>solves multiple linear systems ax=b a is an upper triangular matrix x is the matrix of solution vectors (columns) b is the matrix of right-hand sides (columns) </p>

</div>
</div>
<a class="anchor" id="ad2e78544b79524eecd69073952b0482f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::math::solve </td>
          <td>(</td>
          <td class="paramtype">const low_tri_mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>solves linear system ax=b a is a lower triangular matrix </p>

</div>
</div>
<a class="anchor" id="a296626461f44b387652e79b84cba2457"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::math::solve </td>
          <td>(</td>
          <td class="paramtype">const low_tri_mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>solves multiple linear systems ax=b a is a lower triangular matrix x is the matrix of solution vectors (columns) b is the matrix of right-hand sides (columns) </p>

</div>
</div>
<a class="anchor" id="a14c0b1e4eef5446ab6a31bb7e568a301"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::math::solve </td>
          <td>(</td>
          <td class="paramtype">const diag_mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>solves linear system ax=b a is a diagonal matrix </p>

</div>
</div>
<a class="anchor" id="afa1751b115b38d5f2219959166602e39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::math::solve </td>
          <td>(</td>
          <td class="paramtype">const tri_diag_mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>solves linear system ax=b a is a tri diagonal matrix </p>

</div>
</div>
<a class="anchor" id="a944f8054ed5b163753b2be3da53535d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::math::solve </td>
          <td>(</td>
          <td class="paramtype">const diag_mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>solves multiple linear systems ax=b a is a diagonal matrix x is the matrix of solution vectors (columns) b is the matrix of right-hand sides (columns) </p>

</div>
</div>
<a class="anchor" id="a0e8063281c4be8efe218d82682385a62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::math::solve </td>
          <td>(</td>
          <td class="paramtype">const perm_mat &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>solves linear system ax=b a is a permutation matrix </p>

</div>
</div>
<a class="anchor" id="a28a0d8e1da5521d3dbcad991e8f20649"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::math::solve </td>
          <td>(</td>
          <td class="paramtype">const perm_mat &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>solves multiple linear systems ax=b a is permutation matrix x is the matrix of solution vectors (columns) b is the matrix of right-hand sides (columns) </p>

</div>
</div>
<a class="anchor" id="a4191d37dabc43d6cbc7e5da4dc8f3edd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::math::solve </td>
          <td>(</td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>solve ax=b, standard solver for full storage matrix is lu_solve a is a full storage matrix </p>

</div>
</div>
<a class="anchor" id="af1f874a4044596e0d7f8c4e77e59f4fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::math::solve </td>
          <td>(</td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>solves multiple linear systems ax=b with the svd solver a is full storage matrix x is the matrix of solution vectors (columns) b is the matrix of right-hand sides (columns) </p>

</div>
</div>
<a class="anchor" id="ac01f02edd8e30cf1e4341c07c7c3afae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned cgv::math::solve_underdetermined_system </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00110.html">cgv::math::mat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00127.html">cgv::math::vec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00127.html">cgv::math::vec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00110.html">cgv::math::mat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>return the rank of m x n matrix A with m &lt; n the solution of the system Ax=b is given as x= p + N *(l_1,...,l_{n-r})^T, r is the rank of A, are the free parameters and N is the nullspace </p>

</div>
</div>
<a class="anchor" id="aa0f80cfa8700f246807ae76fa63bbc1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::sphere_val </td>
          <td>(</td>
          <td class="paramtype">const vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A sphere is defined as a vector (a,b,c,r) =&gt; center (a,b,c) and radius revaluate implicit sphere equation at x =(x1,x2,x3) returns signed dist </p>

</div>
</div>
<a class="anchor" id="a1c6452e4900f24398889506f6d1625a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">vec</a>&lt;T&gt; cgv::math::sphere_val </td>
          <td>(</td>
          <td class="paramtype">const vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>xs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>evaluate implicit sphere equation at x =(x1,x2,x3) returns signed dist </p>

</div>
</div>
<a class="anchor" id="a2c64d492a52f234bd13234c434c12c39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::sphere_val2 </td>
          <td>(</td>
          <td class="paramtype">const vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>evaluate implicit sphere equation at x =(x1,x2,x3) returns signed squared dist </p>

</div>
</div>
<a class="anchor" id="acc48a1fe7f24ebdc9910d2bf512e6908"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">vec</a>&lt;T&gt; cgv::math::sphere_val2 </td>
          <td>(</td>
          <td class="paramtype">const vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>xs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>evaluate implicit sphere equation at x =(x1,x2,x3) returns signed dist </p>

</div>
</div>
<a class="anchor" id="a1a12451076df1957fe4247589887704d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cgv::math::sqrdist_transf_1d </td>
          <td>(</td>
          <td class="paramtype">const vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of 1d and 2d linear time distance transformation see: "Distance Transforms of Sampled Functions
Pedro F. Felzenszwalb and Daniel P. Huttenlocher" for details. </p>

</div>
</div>
<a class="anchor" id="a5fcaec03b9e45ded6d1f1e9eadfdffac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::std_value </td>
          <td>(</td>
          <td class="paramtype">const vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>compute the standard deviation (sigma) of all values, normalization is done by n-1 (unbiased estimator) </p>

</div>
</div>
<a class="anchor" id="ab6a005510b7ffa2c6a772d826ba2c164"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::math::svd </td>
          <td>(</td>
          <td class="paramtype">const mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">diag_mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ordering</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>30</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>computes the singular value decomposition of an MxN matrix a = u* w * v^t where u is an MxN matrix, w is a diagonal NxN matrix and v is a NxN square matrix. If the algorithm can't achieve a convergence after 20 iteration false is returned other wise true. The resulting matrices are stored in the parameters u,w,v. Attention: v is returned not v^T ! So to compute the original matrix a from the decomposed matrices you have to multiply u*w*transpose(v). It is possible to store u directly into a to save memory, just put the same reference into a and u. If ordering is true the singular values are sorted in descending order. To ensure that u*w*v^t remains equal to the matrix a the algorithm also exchanges the columns of u and v. </p>

</div>
</div>
<a class="anchor" id="a59c378b0c8a7b79005500080d18dfdf0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cgv::math::var_value </td>
          <td>(</td>
          <td class="paramtype">const vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>compute the variance of all values, normalization is done with n-1 (unbiased estimator) </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00704.html">cgv</a></li><li class="navelem"><a class="el" href="a00711.html">math</a></li>
    <li class="footer">Generated on Mon Jun 26 2017 12:41:49 for cgv by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
